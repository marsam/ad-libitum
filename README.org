* AD LIBITUM

  The Scheme Live Coding Environment. Built on Chez Scheme and libsoundio.

* Getting Started

  This guide describes initial setup required to produce your first piece of
  digital noise with Ad Libitum. At the moment Ad Libitum is tested only on
  MacOS therefore following instructions are MacOS-specific. Any feedback and
  improvement for other platforms is more than welcome! Current state of Ad
  Libitum dependencies is that it should be easy to port it to Linux and
  moderately (but possible) to Windows.

** Chez Scheme

   First, you need Chez Scheme itself. Ad Libitum requires threaded version and
   you probably don't want to install x11 dependency, that's why better to do it
   from source, not brew.

*** Clone Chez Scheme repository

#+BEGIN_SRC shell
git clone https://github.com/cisco/ChezScheme.git
cd ChezScheme
#+END_SRC

*** Exclude X11 from dependencies

   Open =c/version.h= file in your favorite text editor and comment out line
   containing =libX11.dylib= reference:

#+BEGIN_SRC diff
modified   c/version.h
@@ -280,7 +280,7 @@ typedef char *memcpy_t;
 typedef int tputsputcchar;
 #define LOCKF
 #define DIRMARKERP(c) ((c) == '/')
-#define LIBX11 "/usr/X11R6/lib/libX11.dylib"
+/* #define LIBX11 "/usr/X11R6/lib/libX11.dylib" */
 #define _DARWIN_USE_64_BIT_INODE
 #define SECATIME(sb) (sb).st_atimespec.tv_sec
 #define SECCTIME(sb) (sb).st_ctimespec.tv_sec
#+END_SRC

*** Configure, build and install Chez Scheme

#+BEGIN_SRC shell
./configure --threads
make
sudo make install
#+END_SRC

*** Test it's working

    Run =scheme= from terminal and try to evaluate simple expression:

#+BEGIN_SRC shell
~/ChezScheme> scheme

Chez Scheme Version 9.4.1
Copyright 1984-2017 Cisco Systems, Inc.

> (+ 1 2 3)
6
>
#+END_SRC

** libsoundio

   This is library used by Ad Libitum for communication with your computer's
   sound system.

#+BEGIN_SRC shell
brew install libsoundio
#+END_SRC

** Ad Libitum itself

*** Install

   You need to clone repository and build several helping libraries.

#+BEGIN_SRC shell
git clone https://github.com/ul/ad-libitum.git
cd ad-libitum
git submodule update --init --recursive --remote
make
#+END_SRC

*** Test

    Fire up =scheme ad-libitum.ss= and play 440Hz tuner (beware of loud sound!
    reduce speakers/headphones volume before running). Congratulations, you
    livecoded your first Ad Libitum piece!

#+BEGIN_SRC scheme
~/ad-libitum> scheme ad-libitum.ss

Chez Scheme Version 9.4.1
Copyright 1984-2017 Cisco Systems, Inc.

> (sound:set-dsp! tuner)
>
#+END_SRC

*** Play

    Run & =geiser-connect=

#+BEGIN_SRC shell
scheme --optimize-level 3 violet.ss
#+END_SRC
* Contribution

Contribution is more than welcome and highly appreciated! Any small or non-code
fix is valuable as well, including spelling and grammar and setting proper
licensing.

* Kernel

** Sound I/O

   Ad Libitum relies on =chez-soundio= bindings and high-level wrapper. We are
   going to create and open default i/o (only 'o' at the moment) stream and
   provide it globally.

   For performance reasons =chez-sound= itself doesn't provide any protection
   against broken =write-callback=. But in livecoding performance mistakes are
   the part of exploration and arguably we want to sacrifice some performance to
   be able to not restart entire sound subsystem for fixing our
   =write-callback=.

#+NAME: sound
#+BEGIN_SRC scheme
  (define (safe-function f)
    (lambda args
      (try (lambda () (apply f args)) 0.0)))

  (define (silence time channel) 0.0)

  (define *sound-out* (soundio:open-default-out-stream silence))

  (define (set-dsp! f)
    (soundio:sound-out-write-callback-set! *sound-out* (safe-function f)))

  (define (hush!) (set-dsp! silence))

  (define (start) (soundio:start-out-stream *sound-out*))
#+END_SRC

** Scheduler

  Much of music is about time. Before we produce any single sample of wave, we
  want to control when to start and when to stop doing it. Much of live coding
  is about decoupling our commands from their execution. We want to say "play
  note a second later" now, but play it a second later. It's where scheduler
  comes to play. Essentially, scheduler's API is simple and allows to get
  current time mark (whatever it means: system clock, time elapsed from
  scheduler start or number of rendered samples) and to callback procedure at
  some point of time with more or less guaranteed skew limit.

  To have scheduler in sync with audiostream it probably worth to couple it with
  write callback.

  Let's start with scheduler interface. As has been said there are two basic
  functions it must provide:

#+NAME: scheduler-interface
#+BEGIN_SRC scheme
  <<now>>
  <<schedule>>
#+END_SRC

  As far as scheduler is stateful and even involves thread creation, it must
  have two other basic methods:

#+NAME: scheduler-interface
#+BEGIN_SRC scheme
  <<start-scheduler>>
  <<stop-scheduler>>
#+END_SRC

  Let's shape scheduler's data. Obviously, =now= appears here, in form of either
  scheduler's own counter or function (which will get system time or related
  write thread sample number). Another thing is =queue=, where =schedule= will
  store callbacks. And =thread= id or flag or whatever used to control thread
  exit. And the last one which comes to the mind at the moment is =resolution=
  as a time duration of the longest sleep of scheduler thread before checking
  events ready to be fired.

#+NAME: scheduler-record
#+BEGIN_SRC scheme
  (define-record-type scheduler
    (fields now (mutable queue) resolution (mutable thread) mutex))

  (define (simple-scheduler)
    (make-scheduler
     current-time                         ; now
     heap/empty                           ; queue
     (make-time 'time-duration 1000000 0) ; resolution
     #f                                   ; thread
     (make-mutex)                         ; mutex
     ))
#+END_SRC

  =now= then would just call =now= field:

#+NAME: now
#+BEGIN_SRC scheme
  (define (now scheduler) ((scheduler-now scheduler)))
#+END_SRC

  Event queue accepts events which must have =f= with its
  =args= to execute at =time=:

#+NAME: event-record
#+BEGIN_SRC scheme
  (define-record-type event
    (fields time f args))

  (define (event-comparator e1 e2)
    (let ([t1 (event-time e1)]
          [t2 (event-time e2)])
      (cond
       [(time<? t1 t2) 1]
       [(time>? t1 t2) -1]
       [else 0])))
#+END_SRC

  For =queue= we need some heap implementation, I'm going to jump into [[Pairing
  Heap]]!

  Mutex is used to prevent data race on insert and remove from queue happening
  in different threads.

#+NAME: schedule
#+BEGIN_SRC scheme
  (define (schedule scheduler event)
    (with-mutex (scheduler-mutex scheduler)
                (scheduler-queue-set! scheduler (heap/insert event-comparator event (scheduler-queue scheduler)))))
#+END_SRC

  Processing events is just executing any expired events' functions and removing
  them from the queue. Note, that our current implementation is built on the
  assumption that scheduler's clock is based on =current-time=.

  To enable dynamic temporal recursion we evaluate event's =f= as a symbol to be
  resolved in a function, not as an immediate function value.

  Of course, live events are error prone, but we don't want flawed event to blow
  entire thread. Thus =f= execution is secured with =with-exception-handler=.

*** TODO make process-events scheduler clock type independent

*** CODE

#+NAME: process-events
#+BEGIN_SRC scheme
  (define (process-events scheduler t)
    (with-mutex
     (scheduler-mutex scheduler)
     (let next-event ()
       (let ([event (heap/find-min (scheduler-queue scheduler))])
         (when (and event (time<=? (event-time event) t))
           (scheduler-queue-set! scheduler (heap/delete-min event-comparator (scheduler-queue scheduler)))
           (try
            (lambda ()
              (apply (top-level-value (event-f event)) (event-args event)))
            #f)
           (next-event))))))
#+END_SRC

  Now it's a time for start/stop thread. Stopping thread would be just setting a
  flag which I used to call "poison pill".

#+NAME: stop-scheduler
#+BEGIN_SRC scheme
  (define (stop-scheduler scheduler)
    (scheduler-thread-set! scheduler #f))
#+END_SRC

  Starting thread will fork and loop calling expired events.

*** TODO make sleeping scheduler clock type independent

*** CODE

#+NAME: start-scheduler
#+BEGIN_SRC scheme
  (define (start-scheduler scheduler)
    (fork-thread
     (lambda ()
       (scheduler-thread-set! scheduler (get-thread-id))
       (let ([zero-duration (make-time 'time-duration 0 0)]
             [resolution (scheduler-resolution scheduler)])
         (let loop ()
           (when (scheduler-thread scheduler)
             (let ([clock (current-time)]
                   [t (add-duration (now scheduler) resolution)])
               (process-events scheduler t)
               (let* ([day (time-difference (current-time) clock)]
                      [night (time-difference resolution day)])
                 (when (time<? zero-duration night)
                   (sleep night))
                 (loop)))))))))
#+END_SRC

#+NAME: scheduler
#+BEGIN_SRC scheme
  <<scheduler-record>>
  <<event-record>>
  <<process-events>>
  <<scheduler-interface>>
#+END_SRC

  We need just a simple default scheduler at hand for Ad Libitum needs:

#+NAME: easy-scheduler
#+BEGIN_SRC scheme
  (define *scheduler* (simple-scheduler))
  (define (start) (start-scheduler *scheduler*))
  (define (stop) (stop-scheduler *scheduler*))
  (define (*schedule* t f . args) (schedule *scheduler* (make-event t f args)))
  (define (*now*) (now *scheduler*))
#+END_SRC

*** Pairing Heap

   Wikipedia's type definition for pairing heap structure looks like Scheme's
   pairs (surprise =) ). Using them implementation is quite straightforward.

#+NAME: pairing-heap
#+BEGIN_SRC scheme
  ;; we do some #f-punning and don't throw on empty heaps

  (define heap/empty '())

  (define (heap/find-min heap)
    (if (null? heap)
        #f
        (car heap)))

  (define (heap/merge comparator h1 h2)
    (cond
     [(null? h1) h2]
     [(null? h2) h1]
     [(positive? (comparator (car h1) (car h2)))
      (cons (car h1) (cons h2 (cdr h1)))]
     [else
      (cons (car h2) (cons h1 (cdr h2)))]))

  (define (heap/insert comparator elem heap)
    (heap/merge comparator (cons elem '()) heap))

  (define (heap/merge-pairs comparator subheaps)
    (cond
     [(null? subheaps) heap/empty]
     [(null? (cdr subheaps)) (car subheaps)]
     [else (heap/merge comparator
            (heap/merge comparator (car subheaps) (cadr subheaps))
            (heap/merge-pairs comparator (cddr subheaps)))]))

  (define (heap/delete-min comparator heap)
    (if (null? heap)
        heap/empty
        (heap/merge-pairs comparator (cdr heap))))
#+END_SRC

** Remote REPL

  We need own repl server because music doesn't work in geiser repl for somewhat
  reason. The most universal solution would be to have REPL over either UDP or
  TCP with the simplest possible protocol. We want it to be just a carrier,
  everything else should happen inside editor and engine. Sadly Chez Scheme has
  no sockets in its std lib. We are gonna try Aaron W. Hsu's [[https://github.com/arcfide/chez-sockets][chez-sockets]]
  library.

  Actually, we are still able to use Geiser with our REPL server because it
  supports remote REPL. See "Connecting to an external Scheme" at [[http://www.nongnu.org/geiser/geiser_3.html#The-REPL][docs]]. The only
  thing required for it is to load =scheme/chez/geiser/geiser.ss= into the REPL
  thread.

  First, let's create a TCP socket. Here we rely on assumption, that default
  protocol is TCP.

*** TODO ensure that protocol is TCP

  Though Aaron doesn't recommend using blocking sockets, they are so much easier
  for out case! No need to implement polling when waiting for connection or
  receiving value.

  Tried blocking sockets. They work fine by themselves, but play bad with
  =sleep= called from other threads! Falling back to async sockets and polling then.

*** TODO proper socket closing

*** CODE

#+NAME: open-socket
  #+BEGIN_SRC scheme
    (define (open-socket)
      (let ([socket (sock:create-socket
                     sock:socket-domain/internet
                     sock:socket-type/stream
                     sock:socket-protocol/auto)])
        <<bind-socket>>
        <<listen-socket>>
        socket
        ))
  #+END_SRC

  Then we are going to listen address and port for input. We'll make it
  configurable later, let's provide some sensible hardcoded defaults for now.
  /localhost/ is for security reasons, and /37146/ is default Geiser port.

#+NAME: bind-socket
#+BEGIN_SRC scheme
  (sock:bind-socket socket (sock:string->internet-address "127.0.0.1:37146"))
#+END_SRC

  And then let's listen for new connections!

#+NAME: listen-socket
#+BEGIN_SRC scheme
  (sock:listen-socket socket 1024)
#+END_SRC

To actually accept new connections we are going to create new thread and just
run infinite look with =accept-socket= inside. Remember, our socket is
non-blocking so we are to make polling to not eat all CPU by eager calls. After
accepting new connection we'll proceed it in new thread.

#+NAME: accept-connections
#+BEGIN_SRC scheme
  (define (accept-connections repl-server-socket)
    (fork-thread
     (lambda ()
       (let loop ()
         (sleep polling-cycle)
         (let-values ([(socket address) (sock:accept-socket repl-server-socket)])
           (when socket
             (printf "New REPL @ ~s\r\n" (sock:internet-address->string address))
             (spawn-remote-repl socket address)))
         (loop)))))
#+END_SRC

  Every new connection accepted would spawn new thread with a REPL loop inside
  it. Because we are using async sockets, we are forced to run actual loop and
  poll socket for values. /50ms/ should be a reasonable polling delay to keep it
  responsive and not resource greedy at the same time. Also
  =receive-from-socket= require to limit maximum message length. Here /65k/ is
  also is a kind of a guess. Chez Scheme operates UTF-8 strings and messages are
  read as bytevectors from sockets, thus we need a transcoder to convert them
  back and forth. Let's put all these requirements to values:

#+NAME: spawn-remote-repl-options
#+BEGIN_SRC scheme
  (define polling-cycle (make-time 'time-duration 50000000 0))
  (define max-chunk-length 65536)
  (define code-tx (make-transcoder (utf-8-codec) (eol-style lf) (error-handling-mode replace)))
#+END_SRC

  Preparations are straightforward: define some helpers, send initial prompt,
  and start loop.

#+NAME: spawn-remote-repl
#+BEGIN_SRC scheme
  <<spawn-remote-repl-options>>
  (define (spawn-remote-repl socket address)
    (fork-thread
     (lambda ()
       (let* (
              <<repl-send-helpers>>
              )
         (send-prompt)
         <<repl-loop>>
         ))))
#+END_SRC

  Converting messages to bytevectors and sending to proper port is quite
  tedious, let's write a couple of helpers:

#+NAME: repl-send-helpers
#+BEGIN_SRC scheme
  [call-with-send-port
   (lambda (f)
     (let ([response (call-with-bytevector-output-port f code-tx)])
       (sock:send-to-socket socket response address)))]
  [send-prompt
   (lambda ()
     (call-with-send-port (lambda (p) (display "> " p))))]
#+END_SRC

  Loop start with polling delay. For simplicity it's constant and unconditional
  in the beginning of every cycle. If socket is ready and contains non-empty
  message then we do evaluation and send result back. Reading from socket is
  implemented via ports, look at =chez-socket= documentation for more info.

#+NAME: repl-loop
#+BEGIN_SRC scheme
  (let loop ()
    (sleep polling-cycle)
    (let-values ([(request address)
                  (sock:receive-from-socket socket max-chunk-length)])
      (if (and request (positive? (bytevector-length request)))
          (call-with-port
           (open-bytevector-input-port request code-tx)
           <<repl-read-eval-print>>
           )
          (loop))))
#+END_SRC

  Our remote REPL supports multi-form messages, therefore we need inner loop to
  read and process them one by one.

#+NAME: repl-read-eval-print
#+BEGIN_SRC scheme
  (lambda (p)
    (do ([x (read p) (read p)])
        ((eof-object? x))
      (printf "> ~s\r\n" x)
      (call-with-send-port
       <<repl-eval-print>>
       ))
    (send-prompt)
    (loop))
#+END_SRC

  Eval and send result back, easy, huh?

#+NAME: repl-eval-print
#+BEGIN_SRC scheme
  (lambda (p)
    (let* (
           <<repl-eval>>
           )
      <<repl-print>>
      )
    )
#+END_SRC

  Tricky part is that we want to:

    - capture output performed by evaluated form
    - capture result of form evaluated
    - don't blow up on exception and capture its message

  That's why we can't just call =eval=

#+NAME: repl-eval
#+BEGIN_SRC scheme
  [result #f]
  [output
   (with-output-to-string
     (lambda ()
       (set! result (try-display (lambda () (eval x)) #f))))]
#+END_SRC

  On the other hand, sending is quite straightforward, because we need just to
  write to port provided by =call-with-send-port=

#+NAME: repl-print
#+BEGIN_SRC scheme
  (printf "| ~s\r\n" output)
  (printf "< ~s\r\n" result)
  (display output p)
  (display result p)
  (newline p)
#+END_SRC

*** TODO stop loop and close socket on disconnect

*** Start REPL server

#+NAME: start-repl-server
#+BEGIN_SRC scheme
  (define (start-repl-server)
    (accept-connections (open-socket)))
#+END_SRC

* Core

  Woohoo! Naive [[Kernel]] draft is here and we could start to explore Core basics
  of Sound. At this point Ad Libitum splits into into interwinded parts: the
  framework and the book. In the framework we are going to grow all necessary
  instruments for live coding. In the book we are going to use those instruments
  to experiment with sound.

** Math

   Before diving into the abyss of digital music let's define several useful
   basic math constants and functions.

#+NAME: basic-math
#+BEGIN_SRC scheme
  (define pi (* (asin 1.0) 2))
  (define +pi   3.14159265358979323846264)
  (define +pi/2 1.57079632679489661923132)
  (define +pi/4  .78539816339744830961566)
  (define -pi (- +pi))
  (define -pi/2 (- +pi/2))
  (define -pi/4 (- +pi/4))
  (define two-pi (* 2 pi))
#+END_SRC

** Generators

   Sound is about motion. About our mean of sensing somewhat periodic motion
   a.k.a waves. The higher is period, the higher is signal pitch. Waveform
   determines character of signal. And irregularities determine... Something.
   Noise? Personality? We'll try to discover.

   Though signal demonstration usually started with sine waveform as the most
   recognizable and surprisingly pleasant one, we are going to start with
   computationally simplest one (though potentially not the fastest to calculate).

   Technically, the simplest generator is just a constant value, no motion,
   silence. But which stands next in simplicity?

   It's the signal, which is in one position half of a time and in another position
   in another half. By "time" here I mean one cycle, one period of signal.

   But first let define a couple of constants to start with. It's a frequency we
   want to hear and its derivatives.

#+NAME: tuner-constants
#+BEGIN_SRC scheme
  (define tuner-frequency 440.0)
  (define tuner-period (/ 1.0 tuner-frequency))
  (define tuner-half-period (/ tuner-period 2.0))
#+END_SRC

#+NAME: simplest-oscillator
#+BEGIN_SRC scheme
  (define (simplest-oscillator time channel)
    (if (> (mod time tuner-period) tuner-half-period)
        1.0
        -1.0))
#+END_SRC

  Actually, this waveform is called square, because of shape. Once we'll add
  visualisation library to Ad Libitum, before that try to draw function plot by hands.

  Feel free to experiment with different waveforms, we will do it together
  later. Let's step back and look at our example and try to come up with useful
  abstraction. Our DSP callback has signature =f(time, channel) -> amplitude=,
  which is the basis for any audio signal. But what prevents us using audio
  signals as the main medium for building sound? Nothing! It's even very handy.
  Audio signals then are capable of control parameters of other signal,
  naturally forming audio graph. And Chez Scheme should optimize that CSP-like
  style well. But we need to think carefully ahead of time about signature
  itself. What if later we want add additional information flowing every sample?
  What if returning just float is not enough to express all we want? Because
  it's very beautiful, that every signal could be either interpreted as a DSP
  callback alone, and could be passed to other signals. But in the latter case
  sometimes it's not enough to communicate between signals with a single float.
  Perhaps something like =f(time, channel, data) -> (amplitude, data)= could do
  the job? Where structure of =data= is determined by your application, and
  parent signal is responsible for using or discarding the =data= returned by
  child signal. OTOH, =data= in parameters plays like a container for some
  global state to survive between samples, and we could replace it with actual
  global or closured state in our application. The same thing for returned data.

  Let's start with =f(time, channel) -> amplitude= then and pray that we didn't
  overlook something important.

  The most basic signal is just a constant one:

#+NAME: constant
#+BEGIN_SRC scheme
  (define (constant amplitude)
    (lambda (time channel)
      amplitude))
#+END_SRC

  Then we are able to define =silence= as follows:

#+NAME: silence
#+BEGIN_SRC scheme
  (define silence (constant 0.0))
#+END_SRC

  Quick question for self-test: what sound would =(constant 1.0)= produce?

  For unifying oscillators we are going to define signal which will care about
  converting time to proper phase. When you deal with periodic signals it's
  important to distinguish time from phase, because at different frequencies
  phase would be different at the given point of time. Which is okay when
  frequency of you oscillator is constant. When it's variable as in FM
  synthesis, you need to track phase for your oscillator to make it behave
  properly. Let's create special signal =phase= for that purpose. It will take
  =frequency= signal and =phase0= signal and return signal of phase in =[0, 1)=
  half-interval.

#+BEGIN_SRC scheme
  (define (phase frequency phase0)
    (let ([previous-time 0.0]
          [previous-phase 0.0])
      (lambda (time channel)
        (let* ([frequency (frequency time channel)]
               [time-delta (- time previous-time)]
               [phase-delta (* time-delta frequency)]
               [next-phase (mod (+ previous-phase phase-delta (phase0 time channel)) 1.0)])
          (set! previous-time time)
          (set! previous-phase next-phase)
          next-phase))))

  (define (phase* frequency)
    (phase frequency (constant 0.0)))
#+END_SRC

  Here we have an opportunity for a small syntactic improvement. The use-case
  when signal is applied to parameters named exactly time and channel in current
  scope is very common. Let's create a special syntax for it. =@= is chosen as
  resembling =deref= from Clojure:

#+NAME: deref-signal
#+BEGIN_SRC scheme
  (extend-syntax (@) [(@ signal) (signal time channel)])
#+END_SRC

  Let's use it in our phase signal:

#+NAME: phase
#+BEGIN_SRC scheme
  (define (phase frequency phase0)
    (let ([previous-time 0.0]
          [previous-phase 0.0])
      (lambda (time channel)
        (let* ([time-delta (- time previous-time)]
               [phase-delta (* time-delta (@ frequency))]
               [next-phase (mod (+ previous-phase phase-delta (@ phase0)) 1.0)])
          (set! previous-time time)
          (set! previous-phase next-phase)
          next-phase))))

  (define (phase* frequency)
    (phase frequency silence))
#+END_SRC

  Then basic waveforms are defined in very clean way:

#+NAME: waveforms
#+BEGIN_SRC scheme
  (define (sine-wave phase)
    (lambda (time channel)
      (inexact (sin (* two-pi (@ phase))))))

  (define (cosine-wave phase)
    (lambda (time channel)
      (inexact (cos (* two-pi (@ phase))))))

  (define (square-wave phase)
    (lambda (time channel)
      (if (< (@ phase) 0.5)
          1.0
          -1.0)))

  (define (tri-wave phase)
    (lambda (time channel)
      (let ([phase (@ phase)])
        (if (< phase 0.5)
            (- (* 4.0 phase) 1.0)
            (+ (* -4.0 phase) 3.0)))))

  (define (saw-wave phase)
    (lambda (time channel)
      (- (* 2.0 (@ phase)) 1.0)))

  ;; (define (table-wave table phase)
  ;;   (let ([n (vector-length table)])
  ;;     (lambda (time channel)
  ;;       (vector-ref table (exact (truncate (* (@ phase) n)))))))

  (define (table-wave table phase)
    (let ([n (fixnum->flonum (vector-length table))])
      (lambda (time channel)
        (vector-ref table (flonum->fixnum (fltruncate (fl* (@ phase) n)))))))

  (define (random-amplitude)
    (- (random 2.0) 1.0))

  (define (random-wave time channel)
    (random-amplitude))
#+END_SRC

  Before we play something interesting with stuff we already defined we need one
  more helper. Drawback of our way of composition of signals is that we can't
  change code of one of them in live and make changed reloaded live, even if
  signal is not anonymous and was defined as a top-level variable. For signal
  which we plan to reload dynamically we are going to introduce wrapper which
  will look for given signal's symbol on every invocation:

#+NAME: live-signal
#+BEGIN_SRC scheme
  (define (live-signal symbol)
    (lambda (time channel)
      ((top-level-value symbol) time channel)))
#+END_SRC

  Next step is implementation of signal arithmetics to ease their mixing and
  matching.

#+NAME: signal-operators
#+BEGIN_SRC scheme
  (define (signal-sum* x y)
    (lambda (time channel)
      (+ (@ x) (@ y))))

  (define (signal-sum x . xs)
    (fold-left signal-sum* x xs))

  (define (signal-prod* x y)
    (lambda (time channel)
      (* (@ x) (@ y))))

  (define (signal-prod x . xs)
    (fold-left signal-prod* x xs))

  (define (signal-diff x . xs)
    (let ([y (apply signal-sum xs)])
      (lambda (time channel)
        (- (@ x) (@ y)))))

  (define (signal-div x . xs)
    (let ([y (apply signal-prod xs)])
      (lambda (time channel)
        (/ (@ x) (@ y)))))

  (alias +~ signal-sum)
  (alias *~ signal-prod)
  (alias -~ signal-diff)
  (alias /~ signal-div)

  (alias ∑ signal-sum)
  (alias ∏ signal-prod)
#+END_SRC


  For composing signals we could define a helper:

#+NAME: compose
#+BEGIN_SRC scheme
  (define (compose . fns)
    (define (make-chain fn chain)
      (lambda args
        (call-with-values (lambda () (apply fn args)) chain)))
    (reduce make-chain values fns))

  (define ∘ compose)
#+END_SRC

  And use it to define simple osc factory:

#+NAME: oscillator
#+BEGIN_SRC scheme
  (define simple-osc (∘ sine-wave phase* constant))
#+END_SRC


  If you tried to make some composite wave like

#+NAME: make-overtone
#+BEGIN_SRC scheme
  (define (make-overtone wave frequency phase0)
    (+~ (*~ (wave (phase frequency phase0)) (constant 0.4))
        (*~ (wave (phase (*~ (constant 2.0) frequency) phase0)) (constant 0.2))
        (*~ (wave (phase (*~ (constant 3.0) frequency) phase0)) (constant 0.1))
        (*~ (wave (phase (*~ (constant 4.0) frequency) phase0)) (constant 0.1))
        (*~ (wave (phase (*~ (constant 0.5) frequency) phase0)) (constant 0.2))
        ))
#+END_SRC

  And applied it to =sine-wave=:

#+BEGIN_SRC scheme

#+END_SRC

  You might noticed that it's CPU hungry and profiler shows that tons of time is
  spent in system sin function. Let's write a function which will unroll sine
  wave (and any other wave) into a table.


*** TODO add references section
*** TODO add to references link to interactive FFT tutorial

** Envelopes
** Metronome

* Std

** FFT
** Filters
** Instruments
** Scales
** Rhythm

* Misc

  =try= is a little helper to guard function calls in vital loops: dsp,
  scheduler, remote repl.

#+NAME: try
#+BEGIN_SRC scheme
  (define (try thunk default)
    (call/cc
     (lambda (k)
       (with-exception-handler
           (lambda (x) (k default))
         thunk))))
#+END_SRC

#+NAME: try-display
#+BEGIN_SRC scheme
  (define (try-display thunk default)
    (call/cc
     (lambda (k)
       (with-exception-handler
           (lambda (x)
             (display-condition x)
             (k default))
         thunk))))
#+END_SRC

  To import =chez-soundio= and =chez-sockets= we must add respective folders to =library-directories=
  To do that let's create a couple of helpers:

#+NAME: add-library-directories
#+BEGIN_SRC scheme
  (define (add-library-directory dir)
    (library-directories
     (cons dir (library-directories))))

  (define (add-library-directories . dirs)
    (unless (null? dirs)
      (add-library-directory (car dirs))
      (apply add-library-directories (cdr dirs))))

  (add-library-directories
   "./chez-soundio"
   "./chez-sockets")
#+END_SRC

  Also let's define several useful aliases and finally start our services:

#+NAME: ad-libitum-init
#+BEGIN_SRC scheme
  ;; voodoo
  (collect-maximum-generation 254)
  (collect-generation-radix 2)
  (optimize-level 3)

  (alias λ lambda)

  (alias now scheduler:now)
  (alias schedule scheduler:schedule)
  (alias callback schedule)

  ;; in case of emergency ☺
  (alias h! sound:hush!)

  ;; TODO make actual
  (define *channels* 2)

  (sound:start)
  (scheduler:start)
  (repl:start-repl-server)
#+END_SRC

  Tuner stuff to test everything is working:

#+NAME: test-tuner
#+BEGIN_SRC scheme
  (define (sine time freq)
    (sin (* two-pi freq time)))

  (define (tuner time channel)
    ;; inexact because otherwise exact 0 would crash soundio
    (inexact (sine time tuner-frequency)))

  ;; (sound:set-dsp! tuner)
#+END_SRC

  Some stuff about time and scales to be moved to appropriate sections when
  we'll come to them:

#+NAME: sandbox
#+BEGIN_SRC scheme
  (define second (make-time 'time-duration 0 1))
  (define half-second (make-time 'time-duration 500000000 0))
  (define quarter-second (make-time 'time-duration 250000000 0))
  (define 1/8-second (make-time 'time-duration 125000000 0))
  (define 1/16-second (make-time 'time-duration 62500000 0))
  (define 1/32-second (make-time 'time-duration 31250000 0))

  (define (random-choice list)
    (list-ref list (random (length list))))

  (define chromatic-scale-half-step
    (expt 2 1/12))

  (define second-interval (expt chromatic-scale-half-step 2))
  (define third-interval (expt chromatic-scale-half-step 4))
  (define perfect-fourth-interval (expt chromatic-scale-half-step 5))
  (define perfect-fifth-interval (expt chromatic-scale-half-step 7))
  (define major-sixth-interval (expt chromatic-scale-half-step 9))
  (define major-seventh-interval (expt chromatic-scale-half-step 11))
  (define perfect-octave-interval (expt chromatic-scale-half-step 12))
  (define minor-second-interval (expt chromatic-scale-half-step 1))
  (define minor-third-interval (expt chromatic-scale-half-step 3))
  (define minor-sixth-interval (expt chromatic-scale-half-step 8))
  (define minor-seventh-interval (expt chromatic-scale-half-step 11))
  (define triton-interval (expt chromatic-scale-half-step 11))

  ;; TODO excercise: represent scales as whole/half steps

  (define chromatic-scale '(1 2 3 4 5 6 7 8 9 10 11 12))
  (define pentatonic-scale '(1 3 5 8 10))
  (define major-scale '(1 3 5 6 8 10 12))
  (define minor-scale '(1 3 4 6 8 9 11))

  (define (make-scale base-frequency scale)
    (map (lambda (x) (* base-frequency (expt chromatic-scale-half-step (- x 1)))) scale))

  ;;

  (define (unroll signal period sample-rate)
    (let* ([n (exact (truncate (* period sample-rate)))]
           [table (make-vector n)])
      (do ([i 0 (+ i 1)])
          ((= i n))
        (vector-set! table i (inexact (signal (/ i sample-rate) 0))))
      (λ (phase)
        (table-wave table phase))))

  ;; (define table-sine-wave (unroll (simple-osc 0.1) 10 96000))
#+END_SRC

* Files :noexport:

#+BEGIN_SRC scheme :tangle ad-libitum.ss :noweb yes :mkdirp yes :paddle no
  <<add-library-directories>>
  (import (chezscheme)
          (srfi s1 lists)
          (prefix (sound) sound:)
          (prefix (scheduler) scheduler:)
          (prefix (repl) repl:))
  <<ad-libitum-init>>
  <<compose>>
  <<basic-math>>
  <<tuner-constants>>
  <<test-tuner>>
  <<constant>>
  <<silence>>
  <<deref-signal>>
  <<phase>>
  <<waveforms>>
  <<live-signal>>
  <<signal-operators>>
  <<oscillator>>
#+END_SRC

#+BEGIN_SRC scheme :tangle violet.ss :noweb yes :mkdirp yes :paddle no
  (load "ad-libitum.ss")

  <<simplest-oscillator>>
  <<make-overtone>>
  <<sandbox>>
#+END_SRC

#+BEGIN_SRC scheme :tangle sound.ss :noweb yes :mkdirp yes :paddle no
  (library (sound (1))
    (export start set-dsp! hush!)
    (import (chezscheme) (prefix (soundio) soundio:))
    <<try>>
    <<sound>>
    )
#+END_SRC

#+BEGIN_SRC scheme :tangle scheduler.ss :noweb yes :mkdirp yes :paddle no
  (library (scheduler)
    (export start stop
            (rename (*schedule* schedule) (*now* now)))
    (import (chezscheme))
    <<try>>
    <<pairing-heap>>
    <<scheduler>>
    <<easy-scheduler>>
    )
#+END_SRC

#+BEGIN_SRC scheme :tangle repl.ss :noweb yes :mkdirp yes :paddle no
  (library (repl (1))
    (export start-repl-server)
    (import (chezscheme)
            (prefix (bsd-sockets) sock:))
    <<try-display>>
    <<open-socket>>
    <<spawn-remote-repl>>
    <<accept-connections>>
    <<start-repl-server>>
    )
#+END_SRC
