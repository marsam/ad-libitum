<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Ad Libitum</title>
<!-- 2017-10-16 Mon 11:45 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Ruslan Prakapchuk" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Ad Libitum</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. AD LIBITUM</a></li>
<li><a href="#sec-2">2. Getting Started</a>
<ul>
<li><a href="#sec-2-1">2.1. Chez Scheme</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1. Clone Chez Scheme repository</a></li>
<li><a href="#sec-2-1-2">2.1.2. Exclude X11 from dependencies</a></li>
<li><a href="#sec-2-1-3">2.1.3. Configure, build and install Chez Scheme</a></li>
<li><a href="#sec-2-1-4">2.1.4. Test it's working</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2. libsoundio</a></li>
<li><a href="#sec-2-3">2.3. PortMidi</a></li>
<li><a href="#sec-2-4">2.4. Ad Libitum itself</a>
<ul>
<li><a href="#sec-2-4-1">2.4.1. Install</a></li>
<li><a href="#sec-2-4-2">2.4.2. Test</a></li>
<li><a href="#sec-2-4-3">2.4.3. Play</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. Contribution</a></li>
<li><a href="#sec-4">4. Kernel</a>
<ul>
<li><a href="#sec-4-1">4.1. Sound I/O</a></li>
<li><a href="#sec-4-2">4.2. Scheduler</a>
<ul>
<li><a href="#sec-4-2-1">4.2.1. Pairing Heap</a></li>
</ul>
</li>
<li><a href="#sec-4-3">4.3. Remote REPL</a>
<ul>
<li><a href="#sec-4-3-1">4.3.1. <span class="todo TODO">TODO</span> Ensure that protocol is TCP</a></li>
<li><a href="#sec-4-3-2">4.3.2. Blocking vs Async sockets</a></li>
<li><a href="#sec-4-3-3">4.3.3. Open socket</a></li>
<li><a href="#sec-4-3-4">4.3.4. Accept connections</a></li>
<li><a href="#sec-4-3-5">4.3.5. Spawn remote REPL</a></li>
<li><a href="#sec-4-3-6">4.3.6. <span class="todo TODO">TODO</span> Stop loop and close socket on disconnect</a></li>
<li><a href="#sec-4-3-7">4.3.7. Start REPL server</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">5. Core</a>
<ul>
<li><a href="#sec-5-1">5.1. Math</a></li>
<li><a href="#sec-5-2">5.2. Generators</a></li>
<li><a href="#sec-5-3">5.3. Envelopes</a>
<ul>
<li><a href="#sec-5-3-1">5.3.1. ADSR</a></li>
<li><a href="#sec-5-3-2">5.3.2. Impulse</a></li>
<li><a href="#sec-5-3-3">5.3.3. Transition</a></li>
</ul>
</li>
<li><a href="#sec-5-4">5.4. Metronome</a></li>
<li><a href="#sec-5-5">5.5. Control signals</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Std</a>
<ul>
<li><a href="#sec-6-1">6.1. FFT</a></li>
<li><a href="#sec-6-2">6.2. Filters</a></li>
<li><a href="#sec-6-3">6.3. Instruments</a></li>
<li><a href="#sec-6-4">6.4. Scales</a></li>
<li><a href="#sec-6-5">6.5. Rhythm</a></li>
<li><a href="#sec-6-6">6.6. MIDI</a></li>
</ul>
</li>
<li><a href="#sec-7">7. Misc</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> AD LIBITUM</h2>
<div class="outline-text-2" id="text-1">
<p>
The Scheme Live Coding Environment. Built on Chez Scheme and libsoundio.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Getting Started</h2>
<div class="outline-text-2" id="text-2">
<p>
This guide describes initial setup required to produce your first piece of
digital noise with Ad Libitum. At the moment Ad Libitum is tested only on
MacOS therefore following instructions are MacOS-specific. Any feedback and
improvement for other platforms is more than welcome! Current state of Ad
Libitum dependencies is that it should be easy to port it to Linux and
moderately hard (but possible) to Windows.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Chez Scheme</h3>
<div class="outline-text-3" id="text-2-1">
<p>
First, you need Chez Scheme itself. Ad Libitum requires threaded version and
you probably don't want to install x11 dependency, that's why better to do it
from source, not brew.
</p>
</div>

<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> Clone Chez Scheme repository</h4>
<div class="outline-text-4" id="text-2-1-1">
<div class="org-src-container">

<pre class="src src-shell">git clone https://github.com/cisco/ChezScheme.git
cd ChezScheme
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> Exclude X11 from dependencies</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
Open <code>c/version.h</code> file in your favorite text editor and comment out line
containing <code>libX11.dylib</code> reference:
</p>

<div class="org-src-container">

<pre class="src src-diff">modified   c/version.h
@@ -280,7 +280,7 @@ typedef char *memcpy_t;
 typedef int tputsputcchar;
 #define LOCKF
 #define DIRMARKERP(c) ((c) == '/')
-#define LIBX11 "/usr/X11R6/lib/libX11.dylib"
+/* #define LIBX11 "/usr/X11R6/lib/libX11.dylib" */
 #define _DARWIN_USE_64_BIT_INODE
 #define SECATIME(sb) (sb).st_atimespec.tv_sec
 #define SECCTIME(sb) (sb).st_ctimespec.tv_sec
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> Configure, build and install Chez Scheme</h4>
<div class="outline-text-4" id="text-2-1-3">
<div class="org-src-container">

<pre class="src src-shell">./configure --threads
make
sudo make install
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-1-4" class="outline-4">
<h4 id="sec-2-1-4"><span class="section-number-4">2.1.4</span> Test it's working</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
Run <code>scheme</code> from terminal and try to evaluate simple expression:
</p>

<div class="org-src-container">

<pre class="src src-shell">~/ChezScheme&gt; scheme

Chez Scheme Version 9.4.1
Copyright 1984-2017 Cisco Systems, Inc.

&gt; (+ 1 2 3)
6
&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> libsoundio</h3>
<div class="outline-text-3" id="text-2-2">
<p>
This is library used by Ad Libitum for communication with your computer's
sound system.
</p>

<div class="org-src-container">

<pre class="src src-shell">brew install libsoundio
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> PortMidi</h3>
<div class="outline-text-3" id="text-2-3">
<p>
You need it if you plan to use MIDI controller.
</p>

<div class="org-src-container">

<pre class="src src-shell">brew install portmidi
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Ad Libitum itself</h3>
<div class="outline-text-3" id="text-2-4">
</div><div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> Install</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
You need to clone repository and build several helping libraries.
</p>

<div class="org-src-container">

<pre class="src src-shell">git clone https://github.com/ul/ad-libitum.git
cd ad-libitum
git submodule update --init --recursive --remote
make
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> Test</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
Fire up <code>scheme ad-libitum.ss</code> and play 440Hz tuner (beware of loud sound!
reduce speakers/headphones volume before running). Congratulations, you
livecoded your first Ad Libitum piece!
</p>

<div class="org-src-container">

<pre class="src src-scheme">~/ad-libitum&gt; scheme ad-libitum.ss

Chez Scheme Version 9.4.1
Copyright 1984-2017 Cisco Systems, Inc.

&gt; (play! tuner)
&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3"><span class="section-number-4">2.4.3</span> Play</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
Run &amp; <code>geiser-connect</code>
</p>

<div class="org-src-container">

<pre class="src src-shell">scheme --optimize-level 2 violet.ss
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Contribution</h2>
<div class="outline-text-2" id="text-3">
<p>
Contribution is more than welcome and highly appreciated! Any small or non-code
fix is valuable as well, including spelling and grammar and setting proper
licensing.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Kernel</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Sound I/O</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Ad Libitum relies on <code>chez-soundio</code> bindings and high-level wrapper. We are
going to create and open default i/o (only 'o' at the moment) stream and
provide it globally.
</p>

<p>
For performance reasons <code>chez-sound</code> itself doesn't provide any protection
against broken <code>write-callback</code>. But in livecoding mistakes are the part of
exploration and arguably we want to sacrifice some performance to be able to
not restart entire sound subsystem for fixing our <code>write-callback</code>. That's
why calling <code>*dsp*</code> is wrapped into <code>guard</code>.
</p>

<p>
To keep our scheduler clock in sync with audio we store audio time and return
it from <code>now</code> function which is passed to scheduler later.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="sound">;; &lt;sound&gt;
(define *time* 0.0)
(define (now) *time*)

(define (silence time channel) 0.0)
(define *dsp* silence)
(define (set-dsp! f) (set! *dsp* f))
(define (hush!) (set-dsp! silence))

(define (write-callback time channel)
  (set! *time* time)
  (guard (_ [else 0.0])
    (*dsp* time channel)))

(define *sound-out* (soundio:open-default-out-stream write-callback))
(define *sample-rate* (soundio:sample-rate *sound-out*))
(define *channels* (soundio:channel-count *sound-out*))

(define (start) (soundio:start-out-stream *sound-out*))
(define (stop) (soundio:stop-out-stream *sound-out*))
;; &lt;/sound&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Scheduler</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Much of music is about time. Before we produce any single sample of wave, we
want to control when to start and when to stop doing it. Much of live coding
is about decoupling our commands from their execution. We want to say "play
note a second later" now, but play it a second later. It's where scheduler
comes to play. Essentially, scheduler's API is simple and allows to get
current time mark (whatever it means: system clock, time elapsed from
scheduler start or number of rendered samples) and to callback procedure at
some point of time with more or less guaranteed skew limit.
</p>

<p>
Let's start with scheduler interface. As has been said there are two basic
functions it must provide, <code>now</code> and <code>schedule</code>. First one allows to get
current point in time, and it is usually comes to schedule from external
source like audio stream to be in sync with it. Second one allows to schedule
execution at some point in future.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="scheduler-interface">;; &lt;scheduler-interface&gt;
&lt;&lt;now&gt;&gt;
&lt;&lt;schedule&gt;&gt;
;; &lt;/scheduler-interface&gt;
</pre>
</div>

<p>
As far as scheduler is stateful and even involves thread creation, it must
have two other basic methods:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="scheduler-interface">;; &lt;scheduler-interface&gt;
&lt;&lt;start-scheduler&gt;&gt;
&lt;&lt;stop-scheduler&gt;&gt;
;; &lt;/scheduler-interface&gt;
</pre>
</div>

<p>
Let's shape scheduler's data. Obviously, <code>now</code> appears here, in form of either
scheduler's own counter or function (which will get system time or related
write thread sample number). Another thing is <code>queue</code>, where <code>schedule</code> will
store callbacks. Because queuing could happen from different threads at the
same time, as well as dequeuing inside scheduler could happen together with
queuing from another thread, we need to protect it with <code>mutex</code>. We also need
<code>thread</code> id or flag or whatever used to control thread exit, because Scheme
doesn't expose <code>pthread_kill</code>. And the last one which comes to the mind at the
moment is <code>resolution</code> as a number of times per second scheduler checks the
<code>queue</code> for expired events.
</p>

<p>
Together with record definition we provide <code>simple-scheduler</code> which creates
schedule with reasonable default parameters. The only thing it accepts is
<code>now</code>, because usually you want you schedule to be in sync with external
clock.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="scheduler-record">;; &lt;scheduler-record&gt;
(define-record-type scheduler
  (fields now (mutable queue) resolution (mutable thread) mutex))

(define (simple-scheduler now)
  (make-scheduler
   now           ; now
   heap/empty    ; queue
   250           ; resolution
   #f            ; thread
   (make-mutex)  ; mutex
   ))
;; &lt;/scheduler-record&gt;
</pre>
</div>

<p>
Let's implement scheduler interface.
</p>

<p>
<code>now</code> then would just call <code>now</code> field:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="now">;; &lt;now&gt;
(define (now scheduler) ((scheduler-now scheduler)))
;; &lt;/now&gt;
</pre>
</div>

<p>
Event queue accepts events which must have <code>f</code> with its
<code>args</code> to execute at <code>time</code>:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="event-record">;; &lt;event-record&gt;
(define-record-type event
  (fields time f args))
;; &lt;/event-record&gt;
</pre>
</div>

<p>
For <code>queue</code> we need some heap implementation, I'm going to jump into <a href="#sec-4-2-1">4.2.1</a>!
</p>

<p>
Mutex is used to prevent data race on insert and remove from queue happening
in different threads.
</p>

<p>
<code>schedule</code> should accept either <code>event</code> record, or its fields (and create
record by itself) to unclutter user code.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="schedule">;; &lt;schedule&gt;
(define schedule
  (case-lambda
    [(scheduler event)
     (with-mutex (scheduler-mutex scheduler)
		 (scheduler-queue-set! scheduler (heap/insert event-time event (scheduler-queue scheduler))))]
    [(scheduler t f . args)
     (schedule scheduler (make-event (inexact t) f args))]))
;; &lt;/schedule&gt;
</pre>
</div>

<p>
Processing events is just executing any expired events' functions and removing
them from the queue.
</p>

<p>
To enable dynamic temporal recursion we support event's <code>f</code> to be a symbol
referring top level function.
</p>

<p>
Of course, live events are error prone, but we don't want flawed event to blow
entire thread. Thus <code>f</code> execution is secured with <code>guard</code>.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="scheduler-process-events">;; &lt;scheduler-process-events&gt;
(define (process-events scheduler time)
  (with-mutex
   (scheduler-mutex scheduler)
   (let next-event ()
     (let ([event (heap/find-min (scheduler-queue scheduler))])
       (when (and event (&lt;= (event-time event) time))
	 (scheduler-queue-set!
	  scheduler
	  (heap/delete-min event-time (scheduler-queue scheduler)))
	 (guard (_ [else #f])
	   (let ([f (event-f event)])
	     (apply (if (symbol? f)
			(top-level-value f)
			f)
		    (event-args event))))
	 (next-event))))))
;; &lt;/scheduler-process-events&gt;
</pre>
</div>

<p>
Now it's a time for start/stop thread. Stopping thread would be just setting a
flag which I used to call "poison pill".
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="stop-scheduler">;; &lt;stop-scheduler&gt;
(define (stop-scheduler scheduler)
  (scheduler-thread-set! scheduler #f))
;; &lt;/stop-scheduler&gt;
</pre>
</div>

<p>
Starting thread will fork and loop calling expired events. We set expire
period for a half of resolution period in future to compensate a little bit
that events could expire during <code>process-events</code>. Proper adjustment require
further investigation taking in account that audio clock is not uniform (it
moves fast inside filling audio buffer process then waits to buffer to be
available again).
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="start-scheduler">;; &lt;start-scheduler&gt;
(define (start-scheduler scheduler)
  (fork-thread
   (lambda ()
     (scheduler-thread-set! scheduler (get-thread-id))
     (let* ([resolution (scheduler-resolution scheduler)]
	    [expired-horizon (/ 0.5 resolution)]
	    [microseconds-to-sleep (exact (floor (/ 1e6 resolution)))])
       (let loop ()
	 (when (scheduler-thread scheduler)
	   (process-events scheduler (+ (now scheduler) expired-horizon))
	   (usleep 0 microseconds-to-sleep)
	   (loop)))))))
;; &lt;/start-scheduler&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme" id="scheduler">;; &lt;scheduler&gt;
&lt;&lt;scheduler-record&gt;&gt;
&lt;&lt;event-record&gt;&gt;
&lt;&lt;scheduler-process-events&gt;&gt;
&lt;&lt;scheduler-interface&gt;&gt;
;; &lt;/scheduler&gt;
</pre>
</div>

<p>
We need just a simple default scheduler at hand for Ad Libitum needs:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="easy-scheduler">(define *scheduler* #f)
(define (init now) (set! *scheduler* (simple-scheduler now)))
(define (start) (start-scheduler *scheduler*))
(define (stop) (stop-scheduler *scheduler*))
(define (*schedule* t f . args) (schedule *scheduler* (make-event t f args)))
(define (*now*) (now *scheduler*))
</pre>
</div>
</div>

<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1"><span class="section-number-4">4.2.1</span> Pairing Heap</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
Wikipedia's type definition for pairing heap structure looks like Scheme's
pairs (surprise =) ). Using them implementation is quite straightforward.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="pairing-heap">;; &lt;pairing-heap&gt;
;; we do some #f-punning and don't throw on empty heaps

(define heap/empty '())

(define (heap/find-min heap)
  (if (null? heap)
      #f
      (car heap)))

(define (heap/merge comparator h1 h2)
  (cond
   [(null? h1) h2]
   [(null? h2) h1]
   [(&lt; (comparator (car h1)) (comparator (car h2)))
    (cons (car h1) (cons h2 (cdr h1)))]
   [else
    (cons (car h2) (cons h1 (cdr h2)))]))

(define (heap/insert comparator elem heap)
  (heap/merge comparator (cons elem '()) heap))

(define (heap/merge-pairs comparator subheaps)
  (cond
   [(null? subheaps) heap/empty]
   [(null? (cdr subheaps)) (car subheaps)]
   [else (heap/merge comparator
	  (heap/merge comparator (car subheaps) (cadr subheaps))
	  (heap/merge-pairs comparator (cddr subheaps)))]))

(define (heap/delete-min comparator heap)
  (if (null? heap)
      heap/empty
      (heap/merge-pairs comparator (cdr heap))))
;; &lt;/pairing-heap&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Remote REPL</h3>
<div class="outline-text-3" id="text-4-3">
<p>
We need own repl server because music doesn't work in geiser repl for
somewhat reason. The most universal solution would be to have REPL over
either UDP or TCP with the simplest possible protocol. We want it to be just
a carrier, everything else should happen inside editor and engine. Sadly Chez
Scheme has no sockets in its std lib. We are gonna try Aaron W. Hsu's
<a href="https://github.com/arcfide/chez-sockets">chez-sockets</a> library.
</p>

<p>
Actually, we are still able to use Geiser with our REPL server because it
supports remote REPL. See "Connecting to an external Scheme" at <a href="http://www.nongnu.org/geiser/geiser_3.html#The-REPL">docs</a>. The
only thing required for it is to load <code>scheme/chez/geiser/geiser.ss</code> into the
REPL thread.
</p>

<p>
First, let's create a TCP socket. Here we rely on assumption, that default
protocol is TCP.
</p>
</div>

<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1"><span class="section-number-4">4.3.1</span> <span class="todo TODO">TODO</span> Ensure that protocol is TCP</h4>
</div>

<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2"><span class="section-number-4">4.3.2</span> Blocking vs Async sockets</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
Though Aaron doesn't recommend using blocking sockets, they are so much
easier for our case! No need to implement polling when waiting for
connection or receiving value.
</p>

<p>
Tried blocking sockets. They work fine by themselves, but play bad with
<code>sleep</code> called from other threads! Falling back to async sockets and polling
then.
</p>
</div>
</div>

<div id="outline-container-sec-4-3-3" class="outline-4">
<h4 id="sec-4-3-3"><span class="section-number-4">4.3.3</span> Open socket</h4>
<div class="outline-text-4" id="text-4-3-3">
<div class="org-src-container">

<pre class="src src-scheme" id="open-socket">;; &lt;open-socket&gt;
(define (open-socket)
  (let ([socket (sock:create-socket
		 sock:socket-domain/internet
		 sock:socket-type/stream
		 sock:socket-protocol/auto)])
    &lt;&lt;bind-socket&gt;&gt;
    &lt;&lt;listen-socket&gt;&gt;
    socket
    ))
;; &lt;/open-socket&gt;
</pre>
</div>

<p>
Then we are going to listen address and port for input. We'll make it
configurable later, let's provide some sensible hardcoded defaults for now.
<i>localhost</i> is for security reasons, and <i>37146</i> is default Geiser port.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="bind-socket">;; &lt;bind-socket&gt;
(sock:bind-socket socket (sock:string-&gt;internet-address "127.0.0.1:37146"))
;; &lt;/bind-socket&gt;
</pre>
</div>

<p>
And then let's listen for new connections!
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="listen-socket">;; &lt;listen-socket&gt;
(sock:listen-socket socket 1024)
;; &lt;/listen-socket&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-4" class="outline-4">
<h4 id="sec-4-3-4"><span class="section-number-4">4.3.4</span> Accept connections</h4>
<div class="outline-text-4" id="text-4-3-4">
<p>
To actually accept new connections we are going to create new thread and
just run infinite loop with <code>accept-socket</code> inside. Remember, our socket is
non-blocking so we are to make polling to not eat all CPU by eager calls.
After accepting new connection we'll proceed it in new thread.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="accept-connections">;; &lt;accept-connections&gt;
(define (accept-connections repl-server-socket)
  (fork-thread
   (lambda ()
     (let loop ()
       (usleep 0 polling-microseconds)
       (let-values ([(socket address) (sock:accept-socket repl-server-socket)])
	 (when socket
	   (printf "New REPL @ ~s\r\n" (sock:internet-address-&gt;string address))
	   (spawn-remote-repl socket address)))
       (loop)))))
;; &lt;/accept-connections&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-5" class="outline-4">
<h4 id="sec-4-3-5"><span class="section-number-4">4.3.5</span> Spawn remote REPL</h4>
<div class="outline-text-4" id="text-4-3-5">
<p>
Every new connection accepted would spawn new thread with a REPL loop inside
it. Because we are using async sockets, we are forced to run actual loop and
poll socket for values. <i>50ms</i> should be a reasonable polling delay to keep
it responsive and not resource greedy at the same time. Also
<code>receive-from-socket</code> require to limit maximum message length. Here <i>65k</i> is
also is a kind of a guess. Chez Scheme operates UTF-8 strings and messages
are read as bytevectors from sockets, thus we need a transcoder to convert
them back and forth. Let's put all these requirements to values:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="spawn-remote-repl-options">;; &lt;spawn-remote-repl-options&gt;
(define polling-microseconds 50000)
(define max-chunk-length 65536)
(define code-tx (make-transcoder (utf-8-codec) (eol-style lf) (error-handling-mode replace)))
;; &lt;/spawn-remote-repl-options&gt;
</pre>
</div>

<p>
Preparations are straightforward: define some helpers, send initial prompt,
and start loop.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="spawn-remote-repl">;; &lt;spawn-remote-repl&gt;
&lt;&lt;spawn-remote-repl-options&gt;&gt;
(define (spawn-remote-repl socket address)
  (fork-thread
   (lambda ()
     (let* (
	    &lt;&lt;repl-send-helpers&gt;&gt;
	    )
       (send-prompt)
       &lt;&lt;repl-loop&gt;&gt;
       ))))
;; &lt;/spawn-remote-repl&gt;
</pre>
</div>

<p>
Converting messages to bytevectors and sending to proper port is quite
tedious, let's write a couple of helpers:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="repl-send-helpers">;; &lt;repl-send-helpers&gt;
[call-with-send-port
 (lambda (f)
   (let ([response (call-with-bytevector-output-port f code-tx)])
     (sock:send-to-socket socket response address)))]
[send-prompt
 (lambda ()
   (call-with-send-port (lambda (p) (display "&gt; " p))))]
;; &lt;/repl-send-helpers&gt;
</pre>
</div>

<p>
Loop starts with polling delay. For simplicity it's constant and
unconditional in the beginning of every cycle. If socket is ready and
contains non-empty message then we do evaluation and send result back.
Reading from socket is implemented via ports, look at <code>chez-socket</code>
documentation for more info.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="repl-loop">;; &lt;repl-loop&gt;
(let loop ()
  (usleep 0 polling-microseconds)
  (let-values ([(request address)
		(sock:receive-from-socket socket max-chunk-length)])
    (if (and request (positive? (bytevector-length request)))
	(call-with-port
	 (open-bytevector-input-port request code-tx)
	 &lt;&lt;repl-read-eval-print&gt;&gt;
	 )
	(loop))))
;; &lt;/repl-loop&gt;
</pre>
</div>

<p>
Our remote REPL supports multi-form messages, therefore we need inner loop to
read and process them one by one.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="repl-read-eval-print">;; &lt;repl-read-eval-print&gt;
(lambda (p)
  (do ([x (read p) (read p)])
      ((eof-object? x))
    (printf "&gt; ~s\r\n" x)
    (call-with-send-port
     &lt;&lt;repl-eval-print&gt;&gt;
     ))
  (send-prompt)
  (loop))
;; &lt;/repl-read-eval-print&gt;
</pre>
</div>

<p>
Eval and send result back, easy, huh?
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="repl-eval-print">;; &lt;repl-eval-print&gt;
(lambda (p)
  (let* (
	 &lt;&lt;repl-eval&gt;&gt;
	 )
    &lt;&lt;repl-print&gt;&gt;
    )
  )
;; &lt;/repl-eval-print&gt;
</pre>
</div>

<p>
Tricky part is that we want to:
</p>

<ul class="org-ul">
<li>capture output performed by evaluated form
</li>
<li>capture result of form evaluated
</li>
<li>don't blow up on exception and capture its message
</li>
</ul>

<p>
That's why we can't just call <code>eval</code>
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="repl-eval">;; &lt;repl-eval&gt;
[result #f]
[output
 (with-output-to-string
   (lambda ()
     (set! result (guard (x [else (display-condition x)]) (eval x)))))]
;; &lt;/repl-eval&gt;
</pre>
</div>

<p>
On the other hand, sending is quite straightforward, because we need just to
write to port provided by <code>call-with-send-port</code>
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="repl-print">;; &lt;repl-print&gt;
(printf "| ~s\r\n" output)
(printf "&lt; ~s\r\n" result)
(display output p)
(display result p)
(newline p)
;; &lt;/repl-print&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-6" class="outline-4">
<h4 id="sec-4-3-6"><span class="section-number-4">4.3.6</span> <span class="todo TODO">TODO</span> Stop loop and close socket on disconnect</h4>
</div>

<div id="outline-container-sec-4-3-7" class="outline-4">
<h4 id="sec-4-3-7"><span class="section-number-4">4.3.7</span> Start REPL server</h4>
<div class="outline-text-4" id="text-4-3-7">
<div class="org-src-container">

<pre class="src src-scheme" id="start-repl-server">;; &lt;start-repl-server&gt;
(define (start-repl-server)
  (accept-connections (open-socket)))
;; &lt;/start-repl-server&gt;
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Core</h2>
<div class="outline-text-2" id="text-5">
<p>
Woohoo! Naive <a href="#sec-4">4</a> draft is here and we could start to explore Core basics
of Sound. At this point Ad Libitum splits into into interwinded parts: the
framework and the book. In the framework we are going to grow all necessary
instruments for live coding. In the book we are going to use those instruments
to experiment with sound.
</p>

<p>
One of the naming principles of Ad Libitum variables and functions is that
they should have proper long self-describing name for clarity and could have
any funky alias for shortening during performance and for fun cryptic
librettos.
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Math</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Before diving into the abyss of digital music let's define several useful
basic math constants and functions.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="basic-math">;; &lt;basic-math&gt;
(define pi (inexact (* (asin 1.0) 2)))
(define two-pi (* 2.0 pi))
(alias π pi)
(alias 2π two-pi)

(define (random-amplitude)
  (- (random 2.0) 1.0))
;; &lt;/basic-math&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Generators</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Sound is about motion. About our mean of sensing somewhat periodic motion
a.k.a waves. The higher is period, the higher is signal pitch. Waveform
determines character of signal. And irregularities determine&#x2026; Something.
Noise? Personality? We'll try to discover.
</p>

<p>
Though signal demonstration usually started with sine waveform as the most
recognizable and surprisingly pleasant one, we are going to start with
computationally simplest one (though potentially not the fastest to calculate).
</p>

<p>
Technically, the simplest generator is just a constant value, no motion,
silence. But which stands next in simplicity?
</p>

<p>
It's the signal, which is in one position half of a time and in another position
in another half. By "time" here I mean one cycle, one period of signal.
</p>

<p>
But first let define a couple of constants to start with. It's a frequency we
want to hear and its derivatives.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="tuner-constants">;; &lt;tuner-constants&gt;
(define tuner-frequency 440.0)
(define tuner-period (/ tuner-frequency))
(define tuner-half-period (* 0.5 tuner-period))
;; &lt;/tuner-constants&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme" id="simplest-oscillator">;; &lt;simplest-oscillator&gt;
(define (simplest-oscillator time channel)
  (if (&gt; (mod time tuner-period) tuner-half-period)
      1.0
      -1.0))
;; &lt;/simplest-oscillator&gt;
</pre>
</div>

<p>
Actually, this waveform is called square, because of shape. Once we'll add
visualisation library to Ad Libitum, before that try to draw function plot by hands.
</p>

<p>
Feel free to experiment with different waveforms, we will do it together
later. Let's step back and look at our example and try to come up with useful
abstraction. Our DSP callback has signature <code>f(time, channel) -&gt; amplitude</code>,
which is the basis for any audio signal. But what prevents us using audio
signals as the main medium for building sound? Nothing! It's even very handy.
Audio signals then are capable of control parameters of other signal,
naturally forming audio graph. And Chez Scheme should optimize that CSP-like
style well. But we need to think carefully ahead of time about signature
itself. What if later we want add additional information flowing every
sample? What if returning just float is not enough to express all we want?
Because it's very beautiful, that every signal could be either interpreted as
a DSP callback alone, and could be passed to other signals. But in the latter
case sometimes it's not enough to communicate between signals with a single
float. Perhaps something like <code>f(time, channel, data) -&gt; (amplitude, data)</code>
could do the job? Where structure of <code>data</code> is determined by your
application, and parent signal is responsible for using or discarding the
<code>data</code> returned by child signal. OTOH, <code>data</code> in parameters plays like a
container for some global state to survive between samples, and we could
replace it with actual global or closured state in our application. The same
thing for returned data.
</p>

<p>
Let's start with <code>f(time, channel) -&gt; amplitude</code> then and pray that we didn't
overlook something important.
</p>

<p>
To ease writing signal creators and spotting them in code let's introduce
small helper:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="signal">;; &lt;signal&gt;
(define-syntax (signal stx)
  (syntax-case stx ()
    [(k body ...)
     (with-syntax ([time (datum-&gt;syntax #'k 'time)]
		   [channel (datum-&gt;syntax #'k 'channel)])
       #'(λ (time channel) body ...))]))

(alias ~&lt; signal)

(define-syntax (define-signal stx)
  (syntax-case stx ()
    [(k args body ...)
     (with-syntax ([time (datum-&gt;syntax #'k 'time)]
		   [channel (datum-&gt;syntax #'k 'channel)])
       #'(define args
	   (λ (time channel)
	     body ...)))]))

(alias define~ define-signal)
;; &lt;/signal&gt;
</pre>
</div>

<p>
The most basic signal is just a constant one, which is essentially created by
our shiny new syntax <code>(~&lt; amplitude)</code>. But <code>~&lt;</code> is a macro and having
function is useful for composition matters:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="constant">;; &lt;constant&gt;
(define~ (constant amplitude) amplitude)
;; &lt;/constant&gt;
</pre>
</div>

<p>
Then we are able to define <code>silence</code> as follows:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="silence">;; &lt;silence&gt;
(define~ silence 0.0)
(alias ∅ silence)
;; &lt;/silence&gt;
</pre>
</div>

<p>
Quick question for self-test: what sound would <code>(~&lt; 1.0)</code> produce?
</p>

<p>
Though it's still very useful signal, let give it a separate name:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="unit">(define~ unit 1.0)
</pre>
</div>

<p>
For composing signal creators we could define a helper, which is the regular
function composition!
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="compose">;; &lt;compose&gt;
(define (compose . fns)
  (define (make-chain fn chain)
    (λ args (call-with-values (cut apply fn args) chain)))
  (reduce make-chain values fns))

(alias ∘ compose)
;; &lt;/compose&gt;
</pre>
</div>

<p>
For unifying oscillators we are going to define signal which will care about
converting time to proper phase. When you deal with periodic signals it's
important to distinguish time from phase, because at different frequencies
phase would be different at the given point of time. Which is okay when
frequency of you oscillator is constant. When it's variable as in FM
synthesis, you need to track phase for your oscillator to make it behave
properly. Let's create special signal <code>phasor</code> for that purpose. It will take
<code>frequency</code> signal and <code>phase0</code> signal and return signal of phase in <code>[0, 1)</code>
half-interval.
</p>

<p>
Here we have an opportunity for a small syntactic improvement. The use-case
when signal is applied to parameters named exactly <code>time</code> and <code>channel</code> in
current scope is very common. Let's create a special syntax for it.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="deref-signal">(define-syntax (&lt;~ stx)
  (syntax-case stx ()
    [(k signal)
     (with-syntax ([time (datum-&gt;syntax #'k 'time)]
		   [channel (datum-&gt;syntax #'k 'channel)])
       #'(signal time channel))]))
</pre>
</div>

<p>
Let's use it in our phasor signal. Phasor is used so frequently that we want
to provide a small optimization for the case when frequency is known to be
constant.
</p>

<p>
Note that <code>dynamic-phasor</code> relies on being called sample by sample. Skipping
samples is okay-ish (it's like pausing phasor), but calling the same phasor
from several other signals could make it move too fast. We need additional
check to protect it.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="phasor">;; &lt;phasor&gt;
(define (dynamic-phasor frequency phase0)
  (let ([previous-times (make-vector *channels* 0.0)]
	[previous-phases (make-vector *channels* 0.0)])
    (~&lt;
     (let* ([previous-time (vector-ref previous-times channel)]
	    [phase-delta (if (&lt; previous-time time)
			     (/ (&lt;~ frequency) *sample-rate*)
			     0.0)]
	    [next-phase (-&gt; (vector-ref previous-phases channel)
			    (+ phase-delta)
			    (mod 1.0))])
       (vector-set! previous-times channel time)
       (vector-set! previous-phases channel next-phase)
       (-&gt; (&lt;~ phase0)
	   (+ next-phase)
	   (mod 1.0))))))

(define~ (static-phasor frequency phase0)
  (-&gt; time (* frequency) (+ phase0) (mod 1.0)))

(define phasor
  (case-lambda
    [(frequency phase0)
     (if (number? frequency)
	 (static-phasor frequency phase0)
	 (dynamic-phasor frequency phase0))]
    [(frequency)
     (if (number? frequency)
	 (static-phasor frequency 0.0)
	 (dynamic-phasor frequency ∅))]))

(alias /// phasor)
;; &lt;/phasor&gt;
</pre>
</div>

<p>
Then basic waveforms are defined in very clean way:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="waveforms">;; &lt;waveforms&gt;
(define~ (sine phase)
  (sin (* 2π (&lt;~ phase))))

(define~ (cosine phase)
  (cos (* 2π (&lt;~ phase))))

(define~ (square phase)
  (if (&lt; (&lt;~ phase) 0.5)
      1.0
      -1.0))

;; when `pulse-width' is `(constant 0.5)' it's identical to `square-wave'
(define~ (pulse pulse-width phase)
  (if (&lt; (&lt;~ phase) (&lt;~ pulse-width))
      1.0
      -1.0))

(define~ (tri phase)
  (let ([phase (&lt;~ phase)])
    (if (&lt; phase 0.5)
	(- (* 4.0 phase) 1.0)
	(+ (* -4.0 phase) 3.0))))

(define~ (saw phase)
  (- (* 2.0 (&lt;~ phase)) 1.0))

(define (sampler table phase)
  (let ([n (fixnum-&gt;flonum (vector-length table))])
    (~&lt; (vector-ref table (flonum-&gt;fixnum (fltruncate (fl* (&lt;~ phase) n)))))))

(define sine/// (∘ sine phasor))
(define cosine/// (∘ cosine phasor))
(define square/// (∘ square phasor))
(define pulse///
  (case-lambda
    [(pulse-width frequency phase0)
     (pulse pulse-width (phasor frequency phase0))]
    [(pulse-width frequency)
     (pulse pulse-width (phasor frequency ∅))]))
(define tri/// (∘ tri phasor))
(define saw/// (∘ saw phasor))
(define sampler///
  (case-lambda
    [(table frequency) (sampler table (phasor frequency))]
    [(table frequency phase0) (sampler table (phasor frequency phase0))]))
;; &lt;/waveforms&gt;
</pre>
</div>

<p>
Before we play something interesting with stuff we already defined we need
one more helper. Drawback of our way of composition of signals is that we
can't change code of one of them in live and make changed reloaded live, even
if signal is not anonymous and was defined as a top-level variable. For
signal which we plan to reload dynamically we are going to introduce wrapper
which will look for given signal's symbol on every invocation:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="live-signal">;; &lt;live-signal&gt;
(define~ (live-signal symbol) (&lt;~ (top-level-value symbol)))
;; &lt;/live-signal&gt;
</pre>
</div>

<p>
Also useful to have live value counterpart:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="live-value">;; &lt;live-value&gt;
(define~ (live-value symbol) (top-level-value symbol))
;; &lt;/live-value&gt;
</pre>
</div>

<p>
Next step is implementation of signal arithmetics to ease their mixing and
matching.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="signal-operators">;; &lt;signal-operators&gt;
(define~ (signal-sum* x y)
  (+ (&lt;~ x) (&lt;~ y)))

(define (signal-sum x . xs)
  (fold-left signal-sum* x xs))

(define~ (signal-prod* x y)
  (* (&lt;~ x) (&lt;~ y)))

(define (signal-prod x . xs)
  (fold-left signal-prod* x xs))

(define (signal-diff x . xs)
  (let ([y (apply signal-sum xs)])
    (~&lt; (- (&lt;~ x) (&lt;~ y)))))

(define (signal-div x . xs)
  (let ([y (apply signal-prod xs)])
    (~&lt; (/ (&lt;~ x) (&lt;~ y)))))

(alias +~ signal-sum)
(alias *~ signal-prod)
(alias -~ signal-diff)
(alias /~ signal-div)

(define ∑ (cut apply signal-sum &lt;...&gt;))

(define ∏ (cut apply signal-prod &lt;...&gt;))

;; normalizing +~
(define (mix . args)
  (*~ (∑ args) (constant (inexact (/ (sqrt (length args)))))))

(define~ (pan p)
  (let ([p (* 0.5 (+ 1.0 (&lt;~ p)))])
    (if (zero? channel)
	(- 1.0 p)
	p)))
;; &lt;/signal-operators&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Envelopes</h3>
<div class="outline-text-3" id="text-5-3">
</div><div id="outline-container-sec-5-3-1" class="outline-4">
<h4 id="sec-5-3-1"><span class="section-number-4">5.3.1</span> ADSR</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
ADSR envelope shapes signal with polyline described with 4 parameters:
</p>

<ul class="org-ul">
<li>Attack time is the time taken for initial run-up of level from nil to peak,
beginning when the key is first pressed.
</li>
<li>Decay time is the time taken for the subsequent run down from the attack
level to the designated sustain level.
</li>
<li>Sustain level is the level during the main sequence of the sound's
duration, until the key is released.
</li>
<li>Release time is the time taken for the level to decay from the sustain
level to zero after the key is released.
</li>
</ul>

<p>
(Thanks, <a href="https://en.wikipedia.org/wiki/Synthesizer#Attack_Decay_Sustain_Release_.28ADSR.29_envelope">Wikipedia</a>)
</p>

<p>
Two more parameter required to apply envelope in real performance: note's
moments of start and end. To make envelope generic and open for crazy
experiments all 6 parameters are going to be signals:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="adsr">;; &lt;adsr&gt;
(define~ (adsr start end attack decay sustain release)
  (let ([end (&lt;~ end)])
    (if (&lt;= end time)
	;; NOTE OFF
	(let ([Δt (- time end)]
	      [r (&lt;~ release)])
	  (if (and (positive? r)
		   (&lt;= Δt r))
	      (* (- 1.0 (/ Δt r)) (&lt;~ sustain))
	      0.0))
	;; NOTE ON
	(let ([start (&lt;~ start)])
	  (if (&lt;= start time)
	      (let ([Δt (- time start)]
		    [a (&lt;~ attack)])
		(if (and (positive? a)
			 (&lt;= Δt a))
		    (/ Δt a)
		    (let ([Δt (- Δt a)]
			  [d (&lt;~ decay)]
			  [s (&lt;~ sustain)])
		      (if (and (positive? d)
			       (&lt;= Δt d))
			  (- 1.0 (* (- 1.0 s) (/ Δt d)))
			  s))))
	      0.0)))))
;; &lt;/adsr&gt;
</pre>
</div>

<p>
Let's test it with simple note play:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="play-note">;; &lt;play-note&gt;
(define (simple-instrument start end freq a d s r)
  (let* ([start (live-value start)]
	 [end (live-value end)]
	 [freq (live-value freq)]
	 [osc (sine-wave (phasor freq))]
	 [env (adsr start end (~&lt; a) (~&lt; d) (~&lt; s) (~&lt; r))])
    (*~ env osc)))

(define (make-play-note start end frequency)
  (λ (freq dur)
    (set-top-level-value! frequency freq)
    (set-top-level-value! start (now))
    (set-top-level-value! end (+ (now) dur))))

;; (define start 0.0)
;; (define end 1.0)
;; (define frequency 440.0)

;; (define inst (simple-intrument 'start 'end 'frequency 0.3 0.5 0.8 1.0))
;; (define play-note (make-play-note 'start 'end 'frequency))

;; (sound:set-dsp! (live-signal 'inst))
;; (play-note 440.0 1.1)
;; &lt;/play-note&gt;
</pre>
</div>

<p>
We return to instrument concept later and come up with better design for it.
</p>
</div>
</div>

<div id="outline-container-sec-5-3-2" class="outline-4">
<h4 id="sec-5-3-2"><span class="section-number-4">5.3.2</span> Impulse</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
Another simple though useful envelope is impulse.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="impulse">;; &lt;impulse&gt;
(define~ (impulse start apex)
  (let ([start (&lt;~ start)])
    (if (&lt;= start time)
	(let ([h (/ (- time start)
		    (- (&lt;~ apex) start))])
	  (* h (exp (- 1.0 h))))
	0.0)))
;; &lt;/impulse&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-3-3" class="outline-4">
<h4 id="sec-5-3-3"><span class="section-number-4">5.3.3</span> Transition</h4>
<div class="outline-text-4" id="text-5-3-3">
<div class="org-src-container">

<pre class="src src-scheme" id="transition">;; &lt;transition&gt;
(define (transition curve Δt signal)
  (let ([starts (make-vector *channels* (now))]
	[previous-values (make-vector *channels* 0.0)]
	[next-values (make-vector *channels* 0.0)])
    (~&lt;
     (let ([Δt (&lt;~ Δt)]
	   [current-value (&lt;~ signal)]
	   [next-value (vector-ref next-values channel)])
       (unless (= current-value next-value)
	 (vector-set! previous-values channel next-value)
	 (vector-set! next-values channel current-value)
	 (vector-set! starts channel time))
       (let ([δt (- time (vector-ref starts channel))])
	 (if (&lt; δt Δt)
	     (let ([previous-value (vector-ref previous-values channel)])
	       (+ previous-value
		  (curve (/ δt Δt) (- current-value previous-value))))
	     current-value))))))

(define (instant-curve a Δx)
  Δx)

(define (linear-curve a Δx)
  (* a Δx))

(define (quadratic-curve a Δx)
  (* (expt a 4.0) Δx))

(define instant-transition (cut transition instant-curve unit &lt;&gt;))
(define linear-transition (cut transition linear-curve &lt;&gt; &lt;&gt;))
(define quadratic-transition (cut transition quadratic-curve &lt;&gt; &lt;&gt;))
;; &lt;/transition&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Metronome</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Metronome is a mean to align scheduling with some periodic beat.
</p>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> Control signals</h3>
<div class="outline-text-3" id="text-5-5">
<div class="org-src-container">

<pre class="src src-scheme" id="control-signal">;; &lt;control-signal&gt;
(define make-control
  (case-lambda
    [(x)
     (if (number? x)
	 (make-control id x)
	 (make-control x 0.0))]
    [(f x)
     (values (~&lt; x) (λ args (set! x (apply f args))))]))
;; &lt;/control-signal&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme" id="beat">;; &lt;beat&gt;
(define (time-&gt;beat time bpm)
  (-&gt; time (* bpm) (/ 60) (round)))

(define (beat-&gt;time beat bpm)
  (-&gt; beat (* 60) (/ bpm)))

(define (next-beat time bpm)
  (beat-&gt;time (+ 1 (time-&gt;beat time bpm)) bpm))

(define (metro bpm . args)
  (apply schedule (next-beat (now) bpm) args))

(define *bpm* 60.0)

(define (set-bpm! bpm)
  (set! *bpm* bpm))

(define (*beat*)
  (time-&gt;beat (now) *bpm*))

(define (*metro* . args)
  (apply metro *bpm* args))
;; &lt;/beat&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Std</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> FFT</h3>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Filters</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">

<pre class="src src-scheme" id="delay">;; &lt;delay&gt;
(define~ (delay Δt f)
  (f (- time (&lt;~ Δt)) channel))
;; &lt;/delay&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme" id="echo">;; &lt;echo&gt;
(define *max-line-duration* 1)

(define (echo delay feedback signal)
  (let ([line-size (* *max-line-duration* *sample-rate*)]
	[lines (make-vector *channels*)]
	[cursor -1])
    (do ([i 0 (+ i 1)])
	((= i *channels*) 0)
      (vector-set! lines i (make-vector line-size 0.0)))
    (~&lt;
     (when(zero? channel)
       (set! cursor (mod (+ cursor 1) line-size)))
     (let ([line (vector-ref lines channel)]
	   [x (&lt;~ signal)]
	   [delay (flonum-&gt;fixnum (round (* (&lt;~ delay) *sample-rate*)))]
	   [feedback (&lt;~ feedback)])
       (let* ([i (mod (+ line-size (- cursor delay)) line-size)]
	      [y (vector-ref line i)]
	      [z (+ x (* feedback y))])
	 (vector-set! line cursor z)
	 z)))))
;; &lt;/echo&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme" id="lpf">;; &lt;lpf&gt;
(define (lpf-frequency-&gt;α frequency)
  (let ([k (* frequency *sample-angular-period*)])
    (/ k (+ k 1))))

(define (lpf frequency x)
  (let ([ys (make-vector *channels* 0.0)])
    (~&lt;
     (let* ([y-1 (vector-ref ys channel)]
	    [α (lpf-frequency-&gt;α (&lt;~ frequency))])
       (let ([y (+ y-1 (* α (- (&lt;~ x) y-1)))])
	 (vector-set! ys channel y)
	 y)))))
;; &lt;/lpf&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme" id="hpf">;; &lt;hpf&gt;
(define (hpf-frequency-&gt;α frequency)
  (let ([k (* frequency *sample-angular-period*)])
    (/ (+ k 1))))

(define (hpf frequency x)
  (let ([xs (make-vector *channels* 0.0)]
	[ys (make-vector *channels* 0.0)])
    (~&lt;
     (let ([x-1 (vector-ref xs channel)]
	   [y-1 (vector-ref ys channel)]
	   [x (&lt;~ x)]
	   [α (hpf-frequency-&gt;α (&lt;~ frequency))])
       (let ([y (* α (+ y-1 (- x x-1)))])
	 (vector-set! xs channel x)
	 (vector-set! ys channel y)
	 y)))))
;; &lt;/hpf&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme" id="make-biquad-filter">;; &lt;make-biquad-filter&gt;
(define (make-biquad-filter make-coefficients)
  (λ (Q frequency x)
    (let ([xs-1 (make-vector *channels* 0.0)]
	  [xs-2 (make-vector *channels* 0.0)]
	  [ys-1 (make-vector *channels* 0.0)]
	  [ys-2 (make-vector *channels* 0.0)])
      (~&lt;
       (let ([x-1 (vector-ref xs-1 channel)]
	     [x-2 (vector-ref xs-2 channel)]
	     [y-1 (vector-ref ys-1 channel)]
	     [y-2 (vector-ref ys-2 channel)]
	     [x (&lt;~ x)]
	     [Q (&lt;~ Q)]
	     [frequency (&lt;~ frequency)])
	 (let* ([ω (* frequency *sample-angular-period*)]
		[sin-ω (sin ω)]
		[cos-ω (cos ω)]
		[α (/ sin-ω (* 2.0 Q))])
	   (let-values ([(b0 b1 b2 a0 a1 a2) (make-coefficients sin-ω cos-ω α)])
	     (let ([y (-
		       (+
			(* (/ b0 a0) x)
			(* (/ b1 a0) x-1)
			(* (/ b2 a0) x-2))
		       (* (/ a1 a0) y-1)
		       (* (/ a2 a0) y-2))])
	       (vector-set! xs-1 channel x)
	       (vector-set! xs-2 channel x-1)
	       (vector-set! ys-1 channel y)
	       (vector-set! ys-2 channel y-1)
	       y))))))))
;; &lt;/make-biquad-filter&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme" id="biquad-lpf">;; &lt;biquad-lpf&gt;
(define (make-lpf-coefficients sin-ω cos-ω α)
  (let ([b0 (* 0.5 (- 1.0 cos-ω))])
    (values
     b0             ;; b0
     (- 1.0 cos-ω)  ;; b1
     b0             ;; b2
     (+ 1.0 α)      ;; a0
     (* -2.0 cos-ω) ;; a1
     (- 1.0 α)      ;; a2
     )))

(define biquad-lpf (make-biquad-filter make-lpf-coefficients))
;; &lt;/biquad-lpf&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme" id="biquad-hpf">;; &lt;biquad-hpf&gt;
(define (make-hpf-coefficients sin-ω cos-ω α)
  (let ([b0 (* 0.5 (+ 1.0 cos-ω))])
    (values
     b0             ;; b0
     (- -1.0 cos-ω) ;; b1
     b0             ;; b2
     (+ 1.0 α)      ;; a0
     (* -2.0 cos-ω) ;; a1
     (- 1.0 α)      ;; a2
     )))

(define biquad-hpf (make-biquad-filter make-hpf-coefficients))
;; &lt;/biquad-hpf&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Instruments</h3>
<div class="outline-text-3" id="text-6-3">
<div class="org-src-container">

<pre class="src src-scheme" id="polyphony">;; &lt;polyphony&gt;
(define (make-polyphony n make-voice)
  (let ([voices (make-vector n ∅)]
	[cursor 0])
    (let ([signal
	   (apply mix (list-ec (: i n) (~&lt; (&lt;~ (vector-ref voices i)))))]
	  [play-note
	   (λ args
	     (let ([voice (apply make-voice args)])
	       (vector-set! voices cursor voice)
	       (set! cursor (mod (+ cursor 1) n))
	       voice))])
      (values signal play-note))))

(define (make-static-polyphony n make-voice)
  ;; (make-voice) -&gt; (list signal play-note)
  (let ([voices (list-ec (: i n) (make-voice))]
	[cursor 0])
    (let ([signal (apply mix (map first voices))]
	  [play-note
	   (λ args
	     (apply (second (vector-ref voices cursor)) args)
	     (set! cursor (mod (+ cursor 1) n)))])
      (values signal play-note))))
;; &lt;/polyphony&gt;
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> Scales</h3>
<div class="outline-text-3" id="text-6-4">
<p>
We are going to represent scales with Scheme's basic data structure, list.
And the most basic operation which we want to perform on scale is chosing a
note from it without worrying about falling out of range:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="choice">;; &lt;choice&gt;
(define (choice list n)
  (list-ref list (mod n (length list))))

(define (random-choice list)
  (list-ref list (random (length list))))
;; &lt;/choice&gt;
</pre>
</div>

<p>
Basic intervals from Western music.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="intervals">;; &lt;intervals&gt;
(define chromatic-scale-half-step
  (expt 2 1/12))

(define second-interval (expt chromatic-scale-half-step 2))
(define third-interval (expt chromatic-scale-half-step 4))
(define perfect-fourth-interval (expt chromatic-scale-half-step 5))
(define perfect-fifth-interval (expt chromatic-scale-half-step 7))
(define major-sixth-interval (expt chromatic-scale-half-step 9))
(define major-seventh-interval (expt chromatic-scale-half-step 11))
(define perfect-octave-interval (expt chromatic-scale-half-step 12))
(define minor-second-interval (expt chromatic-scale-half-step 1))
(define minor-third-interval (expt chromatic-scale-half-step 3))
(define minor-sixth-interval (expt chromatic-scale-half-step 8))
(define minor-seventh-interval (expt chromatic-scale-half-step 11))
(define triton-interval (expt chromatic-scale-half-step 11))
;; &lt;/intervals&gt;
</pre>
</div>

<p>
Some basic scales from Western music.
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="scales">;; &lt;scales&gt;
(define chromatic-scale '(1 2 3 4 5 6 7 8 9 10 11 12))
(define pentatonic-scale '(1 3 5 8 10))
(define major-scale '(1 3 5 6 8 10 12))
(define minor-scale '(1 3 4 6 8 9 11))

(define (make-scale base-frequency scale)
  (map (λ (x) (* base-frequency (expt chromatic-scale-half-step (- x 1)))) scale))
;; &lt;/scales&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> Rhythm</h3>
<div class="outline-text-3" id="text-6-5">
<div class="org-src-container">

<pre class="src src-scheme" id="pattern">;; &lt;pattern&gt;
(define (play-pattern pattern sound beat)
  (let ([n (length pattern)])
    (when (positive? (choice pattern (exact beat)))
      (sound))))
;; &lt;/pattern&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6"><span class="section-number-3">6.6</span> MIDI</h3>
<div class="outline-text-3" id="text-6-6">
<div class="org-src-container">

<pre class="src src-scheme" id="midi">;; &lt;midi&gt;
(define (*on-note-on* timestamp data1 data2 channel)
  (printf "~s:~s:~s:~s\r\n" timestamp data1 data2 channel))

(define (*on-note-off* timestamp data1 data2 channel)
  (printf "~s:~s:~s:~s\r\n" timestamp data1 data2 channel))

(define (*on-cc* timestamp data1 data2 channel)
  (printf "~s:~s:~s:~s\r\n" timestamp data1 data2 channel))

(define (set-note-on! f) (set! *on-note-on* f))
(define (set-note-off! f) (set! *on-note-off* f))
(define (set-cc! f) (set! *on-cc* f))

(define *polling-cycle* 0.005)

(define *stream* #f)
(define *scheduler* #f)

(define (process-event timestamp type data1 data2 channel)
  (cond
    [(= type pm:*midi-note-on*) (*on-note-on* timestamp data1 data2 channel)]
    [(= type pm:*midi-note-off*) (*on-note-off* timestamp data1 data2 channel)]
    [(= type pm:*midi-cc*) (*on-cc* timestamp data1 data2 channel)]
    [else (printf "Unsupported event type: ~s\r\n" type)]))

(define (make-safe-process-event timestamp)
  (lambda args
    (guard (_ [else #f]) (apply process-event timestamp args))))

(define (process-events)
  (let ([timestamp (scheduler:now *scheduler*)])
    (when (pm:poll *stream*)
      (pm:read *stream* (make-safe-process-event timestamp)))
    (scheduler:schedule *scheduler*
			(+ timestamp *polling-cycle*)
			process-events)))

(define (start now)
  (unless *stream*
    (pm:init)
    (set! *stream* (pm:open-input 0))
    (set! *scheduler* (scheduler:simple-scheduler now))
    (scheduler:start-scheduler *scheduler*)
    (process-events)))

(define (stop)
  (when *stream*
    (scheduler:stop-scheduler *scheduler*)
    (pm:close *stream*)
    (pm:terminate)
    (set! *stream* #f)
    (set! *scheduler* #f)))
;; &lt;/midi&gt;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Misc</h2>
<div class="outline-text-2" id="text-7">
<p>
To import <code>chez-soundio</code> and <code>chez-sockets</code> we must add respective folders to
<code>library-directories</code> To do that let's create a couple of helpers:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="add-library-directories">;; &lt;add-library-directories&gt;
(define (add-library-directory dir)
  (library-directories
   (cons dir (library-directories))))

(define (add-library-directories . dirs)
  (unless (null? dirs)
    (add-library-directory (car dirs))
    (apply add-library-directories (cdr dirs))))

(add-library-directories
 "./chez-soundio"
 "./chez-portmidi"
 "./chez-sockets")
;; &lt;/add-library-directories&gt;
</pre>
</div>

<p>
Also let's define several useful aliases and finally start our services:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="ad-libitum-init">;; &lt;ad-libitum-init&gt;
(alias now sound:now)
(alias schedule scheduler:*schedule*)
(alias callback schedule)

;; in case of emergency ☺
(alias h! sound:hush!)

(alias play! sound:set-dsp!)

(sound:start)
(scheduler:init now)
(scheduler:start)
(repl:start-repl-server)
;; &lt;/ad-libitum-init&gt;
</pre>
</div>

<p>
Tuner stuff to test everything is working:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="test-tuner">;; &lt;test-tuner&gt;
(define (tuner time channel)
  (sin (* 2π time tuner-frequency)))

;; (sound:set-dsp! tuner)
;; &lt;/test-tuner&gt;
</pre>
</div>

<p>
Some stuff about time and scales to be moved to appropriate sections when
we'll come to them:
</p>

<div class="org-src-container">

<pre class="src src-scheme" id="sandbox">;; &lt;sandbox&gt;
(define (unroll signal period)
  (let* ([n (exact (truncate (* period *sample-rate*)))]
	 [table (make-vector n)])
    (do ([i 0 (+ i 1)])
	((= i n))
      (vector-set! table i (inexact (signal (/ i *sample-rate*) 0))))
    (cut sampler table &lt;&gt;)))

(define (make-overtone amplitudes wave frequency phase0)
  (∑ (map
      (λ (amplitude factor)
	(let ([factor (inexact factor)])
	  (*~ amplitude
	      (wave (osc:phasor (*~ (~&lt; factor) frequency) phase0)))))
      amplitudes
      (iota (length amplitudes)))))

(define (fix-duration duration)
  (let* ([start (now)]
	 [end (+ start duration)])
    (values (~&lt; start) (~&lt; end))))

(define~ (amplitude-&gt;phase s)
  (* 0.5 (+ 1.0 (&lt;~ s))))
;; &lt;/sandbox&gt;
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Ruslan Prakapchuk</p>
<p class="date">Created: 2017-10-16 Mon 11:45</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
