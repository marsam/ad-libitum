#+TITLE: The Theory and Technique of Electronic Music Exercises in Ad Libitum
#+SETUPFILE: org-html-themes/setup/theme-readtheorg.setup

  It's my exercise book for studying "The Theory and Technique of Electronic
  Music" by Miller Puckette. Work is done in Ad Libitum instead of PureData, and
  some pieces of code migrate back to Ad Libitum standard library.

  You might want to read this file here [[http://ul.mantike.pro/ad-libitum/TTEM.html]]

* Sinusoids, amplitude and frequency

  Ad Libitum deals with continous representation of time, it's expressed as a
  float number of seconds passed from the stream start. For any signal either
  continous or discrete feels more natural, and there is no clear measure of
  their shares. Good news that conversion is relatively easy in both directions.

  =~<= is a syntax sugar which wraps code into function of two parameters:
  =time= and =channel=, which are thrown in scope. Such kind of function is how
  Ad Libitum represents audio signals. Think about time as a continuous
  counterpart of sample number =n= in TTEM. =channel= will be discussed later.
  Think about =~<= as the thing which animates your formula to produce signal.

#+BEGIN_SRC scheme
  (define (sinusoid a ω φ) (~< (* a (cos (+ (* ω time) φ)))))
#+END_SRC

  =play!= connects your signal to audio output and you can hear it! Amplitude
  range in Ad Libitum is [-1, 1], setting a=0.2 we are producing signal in 1/5
  of it.

#+BEGIN_SRC scheme
  (play! (sinusoid 0.2 2000.0 0.0))
#+END_SRC

  And the most important function in Ad Libitum — =h!= hush!

#+BEGIN_SRC scheme
  (h!)
#+END_SRC

  Let's make sinusoid to receive regular frequency instead of angular one.

#+BEGIN_SRC scheme
  (define (ƒ→ω ƒ)
    (* 2π ƒ))

  (define (ω→ƒ ω)
    (/ ω 2π))

  (define (sinusoid a ƒ φ)
    (~< (* a (cos (+ (* (ƒ→ω ƒ) time) φ)))))

  (play! (sinusoid 0.2 440.0 0.0))
  (h!)
#+END_SRC

** Measures of Amplitude

   This is not a blood pact, but many of Ad Libitum code relies on fact that
   audiosignal is called sample by sample, without skips. Making that assumption
   we are able to write RMS amplitude measurement even in continuous
   representation of time.

#+BEGIN_SRC scheme
  (define (rms-amplitude window-width s)
    (let ([windows (make-vector *channels*)]
          [N (-> window-width (* *sample-rate*) (ceiling) (exact))]
          [cursor -1])
      (do-ec (: i *channels*)
             (vector-set! windows i (make-vector N 0.0)))
      (~<
       (when (zero? channel)
         (set! cursor (mod (+ cursor 1) N)))
       (let ([window (vector-ref windows channel)]
             [x 0.0])
         (vector-set! window cursor (<~ s))
         (vector-for-each (λ (y) (set! x (+ x (* y y)))) window)
         (sqrt (/ x N))))))
#+END_SRC

   Let's make sinusoid amplitude a signal, and set it to rms amplitude measured
   from sinusoid with peak amplitude 1.0
   Note =<~= syntax sugar to apply audiosignal function to time and channel.
   =(<~ a)= is equivalent to =(a time channel)=
   Also note how we make constant signal with =(~< 1.0)=

#+BEGIN_SRC scheme
  (define (sinusoid a ƒ φ)
    (~< (* (<~ a) (cos (+ (* (ƒ→ω ƒ) time) φ)))))
#+END_SRC

   Note that computing rms in realtime is very expensive.
   Try to increase window width until you get audio buffer underflow glitches.

#+BEGIN_SRC scheme
  (play! (sinusoid (rms-amplitude 2/440 (sinusoid (~< 1.0) 440.0 0.0)) 440.0 0.0))
  (h!)
#+END_SRC

   Compare with 1.0 peak itself, it's louder!

#+BEGIN_SRC scheme
  (play! (sinusoid (~< 1.0) 440.0 0.0))
  (h!)
#+END_SRC

   Let's throttle =rms-amplitude= to make it less hungry

#+BEGIN_SRC scheme
  (define (rms-amplitude window-width s)
    (let ([windows (make-vector *channels*)]
          [N (-> window-width (* *sample-rate*) (ceiling) (exact))]
          [cursor -1]
          [amplitudes (make-vector *channels* 0.0)])
      (do-ec (: i *channels*)
             (vector-set! windows i (make-vector N 0.0)))
      (~<
       (when (zero? channel)
         (set! cursor (mod (+ cursor 1) N)))
       (let ([window (vector-ref windows channel)])
         (vector-set! window cursor (<~ s))
         (when (zero? cursor)
           (vector-set!
            amplitudes
            channel
            (let ([x 0.0])
              (vector-for-each (λ (y) (set! x (+ x (* y y)))) window)
              (sqrt (/ x N))))))
       (vector-ref amplitudes channel))))

  (play! (sinusoid (rms-amplitude 1 (+~ (sinusoid (~< 1.0) 440.0 0.0))) 440.0 0.0))
  (h!)
#+END_SRC

   Chez Scheme GC is so cool that though we produce a lot of garbage every
   second it doesn't interrupt sound! But we still have a noticeable lag on
   window initialization. Take it into account if you are going to spawn
   capacitive =rms-amplitude= signals frequently.

   In future for sinusoid we will use built-in Ad Libitum oscillator available
   as =osc:sine= (takes phasor signal as input, we'll cover it later) and
   =osc:sine///= (takes frequency and optional initial phase).

#+BEGIN_SRC scheme
  (play! (osc:sine (osc:phasor 440.0 0.0)))
  (play! (osc:sine/// 440.0 0.0))
  (h!)
#+END_SRC

** Units of Amplitude

   Convert amplitude to decibels, with a0 = 1e-5 as suggested in TTEM

#+BEGIN_SRC scheme
  (define (amp->dB x)
    (* 20.0 (log (* x 1e5) 10.0)))

  (amp->dB 1.0)
  (amp->dB 0.5)
#+END_SRC

   But setting a0 to 1.0 is also very convenient — maximum amplitude is then 0dB
   and any one below is just negative. All relations stays the same.

#+BEGIN_SRC scheme
  (define (amp->dB x)
    (* 20.0 (log x 10.0)))

  (amp->dB 0.5)
  (amp->dB 1e-5)
#+END_SRC

   And convert decibels back to amplitude:

#+BEGIN_SRC scheme
  (define (dB->amp x)
    (expt 10.0 (/ x 20.0)))

  (dB->amp -100.0)
  (dB->amp -50.0)
  (dB->amp -10.0)
  (dB->amp 0.0)
#+END_SRC

   Amplitude is related in an inexact way to the perceived loudness of a sound.
   In general, two signals with the same peak or RMS amplitude won’t necessarily
   have the same loudness at all. But amplifying a signal by 3 dB, say, will
   fairly reliably make it sound about one “step” louder.

#+BEGIN_SRC scheme
  (define *volume-step-dB* 3.0)
#+END_SRC

   Let's test it!

#+BEGIN_SRC scheme
  (define (sinusoid a ƒ φ)
    (~< (* a (cos (+ (* (ƒ→ω ƒ) time) φ)))))
  (play! (sinusoid (dB->amp -10.0) 440.0 0.0))
  (play! (sinusoid (dB->amp (- 10.0 *volume-step-dB*)) 440.0 0.0))
  (h!)
#+END_SRC

   Try to change step. For that wave personally I hear 2dB difference.

** Controlling Amplitude

   We already controlled amplitude by multiplying every sample by =a=
   Let's do it by multiplying sinusoid by constant signal.

#+BEGIN_SRC scheme
  (play! (*~ (~< 0.5) (osc:sine/// 440.0)))
  (play! (*~ (~< 0.2) (osc:sine/// 440.0)))
  (h!)
#+END_SRC

** Frequency

#+BEGIN_SRC scheme
  (define (midi-pitch->frequency m)
    (* 440.0 (expt 2.0 (/ (- m 69.0) 12.0))))

  (define (frequency->midi-pitch f)
    (+ 69 (exact (round (* 12.0 (log (/ f 440.0) 2.0))))))

  (play! (osc:sine/// (midi-pitch->frequency 69)))
  (play! (osc:sine/// (midi-pitch->frequency 72)))
  (h!)
#+END_SRC

   Ad Libitum allows you to use MIDI controller. Support is still incomplete and
   relies on many assumptions. Your MIDI input device should be connected and
   identified as the first one.
   =now= is Ad Libitum clock function. It's required for MIDI module to put
   proper timestamps on events.

#+BEGIN_SRC scheme
  (midi:start now)
#+END_SRC

   Let's defined so called control signal for our frequency. We'll speak about
   control signals later, but putting it simply, control signal is an audio
   signal which is updated in non-audio rate by calling its setter.

#+BEGIN_SRC scheme
  (define-values (frequency set-frequency!) (ctrl:make-control 440.0))
#+END_SRC

   Let's set callback which will be called for every control change MIDI event.

#+BEGIN_SRC scheme
  (midi:set-cc! (λ (t knob value channel)
                  (set-frequency! (midi-pitch->frequency value))))

  (play! (osc:sine/// frequency))
  (h!)
#+END_SRC

   Notice that abrupt change of frequency cause "pops" discussed in TTEM 1.5

** Synthesizing a sinusoid

   To make transition smooth we could use built-in =env:linear-transition=

#+BEGIN_SRC scheme
  (define-values (frequency set-frequency!) (ctrl:make-control 440.0))

  (play! (osc:sine/// (env:linear-transition (~< 0.05) frequency)))
  (h!)
#+END_SRC

   Besides of using MIDI input we could make frequency change programmatically.
   =schedule= allows you to call any function later at given point of time.
   Any function could schedule itself. It is called temporal recursion.

#+BEGIN_SRC scheme
  (define (swap-frequency i)
    (if (zero? i)
        (set-frequency! 440.0)
        (set-frequency! 220.0))
    (schedule (+ (now) 1/4) 'swap-frequency (- 1 i)))

  (swap-frequency 0)

  (play! (osc:sine/// frequency))
  (play! (osc:sine/// (env:linear-transition (~< 0.05) frequency)))
  (play! (osc:sine/// (env:quadratic-transition (~< 0.05) frequency)))
  (h!)
#+END_SRC

** Superposing Signals

   To superpose signals in Ad Libitum signal sum operator =+~= is available.

#+BEGIN_SRC scheme
  (play! (+~ (*~ (~< 0.5) (osc:sine/// (midi-pitch->frequency 69)))
             (*~ (~< 0.5) (osc:sine/// (midi-pitch->frequency 72)))))
  (h!)
#+END_SRC

   Let's measure how peak and rms amplitude of sinusoids superposition relates
   to sum of their amplitudes.

   For that we need to define =peak-amplitude= signal.

#+BEGIN_SRC scheme
  (define (peak-amplitude signal)
    (let ([peaks (make-vector *channels* 0.0)])
      (~<
       (let* ([sample (<~ signal)]
              [peak (max sample (vector-ref peaks channel))])
         (vector-set! peaks channel peak)
         peak))))
#+END_SRC

   Because Ad Libitum signals are kind of pull FRP, we can't just wrap our
   signal with =rms-amplitude= and then play initial signal and have RMS one
   updated. Let's define useful signal which keep signals given to it updated,
   but plays only first one.

#+BEGIN_SRC scheme
  (define (solo audio . muted)
    (~<
     (for-each (cut <> time channel) muted)
     (<~ audio)))
#+END_SRC

   Uncorrelated signals.

#+BEGIN_SRC scheme
  (define signal-1 (*~ (~< 0.5) (osc:sine/// (midi-pitch->frequency 69))))
  (define signal-2 (*~ (~< 0.5) (osc:sine/// (midi-pitch->frequency 72))))

  (define superposed-signal (+~ signal-1 signal-2))

  ;; signal-1 and signal-2 peaks are obviously 0.5
  (define measure-peak (peak-amplitude superposed-signal))

  (define measure-rms-signal-1-2 (rms-amplitude 0.1 signal-1))
  (define measure-rms (rms-amplitude 0.1 superposed-signal))

  (play! (solo superposed-signal measure-peak measure-rms measure-rms-signal-1-2))
  (h!)

  (measure-peak 0.0 0) ;; => 0.9999931184993082
  (measure-rms 0.0 0) ;; => 0.5038381755150125
  (measure-rms-signal-1-2 0.0 0) ;; => 0.3535533905956031
#+END_SRC

   Correlated signals.

#+BEGIN_SRC scheme
  (define signal-1 (*~ (~< 0.5) (osc:sine/// 440.0)))
  (define signal-2 (*~ (~< 0.5) (osc:sine/// 440.0)))

  (define superposed-signal (+~ signal-1 signal-2))

  ;; signal-1 and signal-2 peaks are obviously 0.5
  (define measure-peak (peak-amplitude superposed-signal))

  (define measure-rms-signal-1-2 (rms-amplitude 0.1 signal-1))
  (define measure-rms (rms-amplitude 0.1 superposed-signal))

  (play! (solo superposed-signal measure-peak measure-rms measure-rms-signal-1-2))
  (h!)

  (measure-peak 0.0 0) ;; => 1.0
  (measure-rms 0.0 0) ;; => 0.7071067811829478
  (measure-rms-signal-1-2 0.0 0) ;; => 0.3535533905914739
#+END_SRC

   To be honest, trick with =solo= points to drawbacks in =rms-amplitude= and
   =peak-amplitude= design. It would be better for them to just proxy input
   signal and provide some accessor to measurement result.

#+BEGIN_SRC scheme
  (define (peak-amplitude signal)
    (let ([peaks (make-vector *channels* 0.0)])
      (values
       (~<
        (let* ([sample (<~ signal)]
               [peak (max sample (vector-ref peaks channel))])
          (vector-set! peaks channel peak)
          sample))
       (λ () peaks))))

  (define (window width signal)
    (let ([windows (make-vector *channels*)]
          [N (-> width (* *sample-rate*) (ceiling) (exact))]
          [cursor -1])
      (do-ec (: i *channels*)
             (vector-set! windows i (make-vector N 0.0)))
      (values
       (~<
        (when (zero? channel)
          (set! cursor (mod (+ cursor 1) N)))
        (let ([sample (<~ signal)]
              [window (vector-ref windows channel)])
          (vector-set! window cursor sample)
          sample))
       (λ () windows))))

  (define (rms-amplitude window-width signal)
    (let-values ([(signal windows) (window window-width signal)])
      (values
       signal
       (λ ()
         (vector-map
          (λ (window)
            (let ([x 0.0])
              (vector-for-each (λ (y) (set! x (+ x (* y y)))) window)
              (sqrt (/ x (vector-length window)))) )
          (windows))))))
#+END_SRC

#+BEGIN_SRC scheme
  (define signal-1 (*~ (~< 0.5) (osc:sine/// (midi-pitch->frequency 69))))
  (define signal-2 (*~ (~< 0.5) (osc:sine/// (midi-pitch->frequency 72))))

  (define superposed-signal (+~ signal-1 signal-2))

  (define-values (superposed-signal measure-peak) (peak-amplitude superposed-signal))
  (define-values (superposed-signal measure-rms) (rms-amplitude 0.1 superposed-signal))

  (play! superposed-signal)
  (h!)

  (measure-peak)
  (measure-rms)
#+END_SRC

** Periodic Signals

#+BEGIN_SRC scheme
  (define s1 (*~ (~< 0.5) (osc:sine/// 220.0 0.0)))
  (define s2 (*~ (~< 0.3) (osc:sine/// 440.0 0.1)))
  (define s3 (*~ (~< 0.2) (osc:sine/// 660.0 0.2)))

  (play! (+~ s1 s2 s3))

  (h!)
#+END_SRC

** About the Software Examples

   Oh, well... You are already running Ad Libitum at this point.

** Examples

*** Constant amplitude scaler

    Note how Pd boxes corresponds to Ad Libitum expressions in parenthesis, and
    instead of graph-like connections tree structure is used. Don't judge fast
    it as limiting, you always can reuse expression by naming it with help of
    =define= or =let=, and we will show later how powerful is textual
    representation.

#+BEGIN_SRC scheme
  (play!
   (*~
    (~< 0.05)
    (osc:sine/// 440.0)))

  (h!)

  ;;; or

  (define sinusoid (osc:sine/// 440.0))
  (define amplitude (~< 0.05))
  (define scaled-sinusoid (*~ amplitude sinusoid))

  (play! scaled-sinusoid)

  (h!)
#+END_SRC

*** Amplitude control in decibels

#+BEGIN_SRC scheme
  (define amplitude 0.0)
  (define amplitude~ (live-value 'amplitude))

  (define (set-amplitude! dB)
    (set! amplitude (dB->amp dB)))

  (play! (*~ amplitude~ (osc:sine/// 440.0)))

  (set-amplitude! 0) ;; beware of loud sound
  (set-amplitude! -10)
  (set-amplitude! -20)
  (set-amplitude! -50)

  (h!)
#+END_SRC

*** Smoothed envelope control with an envelope generator

    Note, that in *𝔄𝔏* instead of messages we just set values or invoke function
    which do that.

#+BEGIN_SRC scheme
  (define (make-line)
    (let-values ([(value set-value!) (ctrl:make-control 0.0)]
                 [(Δt set-Δt!) (ctrl:make-control 0.0)])
      (values
       (env:linear-transition Δt value)
       set-value!
       set-Δt!)))

  (define-values (line~ set-amplitude! set-Δt!) (make-line))

  (define (slow-on)
    (set-Δt! 2.0)
    (set-amplitude! 0.1))

  (define (fast-on)
    (set-Δt! 0.05)
    (set-amplitude! 0.1))

  (define (instant-on)
    (set-Δt! 0.0)
    (set-amplitude! 0.1))

  (define (slow-off)
    (set-Δt! 2.0)
    (set-amplitude! 0.0))

  (define (fast-off)
    (set-Δt! 0.05)
    (set-amplitude! 0.0))

  (define (instant-off)
    (set-Δt! 0.0)
    (set-amplitude! 0.0))

  (play! (*~ (osc:sine/// 440.0) line~))

  (slow-on)
  (slow-off)

  (fast-on)
  (fast-off)

  (instant-on)
  (instant-off)

  (h!)
#+END_SRC

*** Major triad

    =mix= is normalizing =+~=

#+BEGIN_SRC scheme
  (play!
   (mix (osc:sine/// 440.0)
        (osc:sine/// 550.0)
        (osc:sine/// 660.0)))

  (h!)
#+END_SRC

*** Conversion between frequency and pitch

    This is covered well before. Only worth to note once more that in *𝔄𝔏*
    instead of message passing we just give names, set values and call functions.

*** More additive synthesis


#+BEGIN_SRC scheme
  (define-values
    (frequency set-pitch!)
    (ctrl:make-control midi-pitch->frequency 0.0))

  (define s1 (osc:sine/// frequency))
  (define s2 (*~ (~< 0.1) (osc:sine/// (*~ (~< 2.0) frequency))))
  (define s3 (*~ (~< 0.2) (osc:sine/// (*~ (~< 3.0) frequency))))
  (define s4 (*~ (~< 0.5) (osc:sine/// (*~ (~< 4.0) frequency))))

  (define (switch)
    (let ([value 0.0])
      (values
       (~< value)
       (λ () (set! value (- 1.0 value))))))

  (define-values (overtones-switch toggle-overtones!) (switch))

  (play! (+~ s1
             (*~ overtones-switch
                 (+~ s2 s3 s4))))

  (set-pitch! 69)
  (toggle-overtones!)

  (set-pitch! 50)
  (toggle-overtones!)

  (h!)
#+END_SRC

** Exercises

#+BEGIN_SRC scheme
  ;;; 1

  (define φ 0.0)
  (define ω (/ π 10.0))

  ;; ? phase at sample n = 10

  (+ (* ω 10) φ)

  ;;; 2

  (define sinusoid-1-period 20)
  (define sinusoid-2-period 30)

  ;; ? period of sum

  (lcm sinusoid-1-period sinusoid-2-period)

  ;;; 3

  (amp->dB 1.5)
  (amp->dB 2)
  (amp->dB 3)
  (amp->dB 5)

  ;;; 4

  (define signal-1-rms-amplitude 3)
  (define signal-2-rms-amplitude 4)

  ;; ? rms amplitude of signals sum

  (sqrt (+ (* signal-1-rms-amplitude signal-1-rms-amplitude)
           (* signal-2-rms-amplitude signal-2-rms-amplitude)))

  ;; let's double-check with real signal
  (define s1 (*~ (~< (* signal-1-rms-amplitude (sqrt 2)))
                 (osc:sine/// 440.0)))

  (define s2 (*~ (~< (* signal-2-rms-amplitude (sqrt 2)))
                 (osc:sine/// 543.0)))

  (define-values (s1* measure-s1-rms) (rms-amplitude 0.1 s1))
  (define-values (s2* measure-s2-rms) (rms-amplitude 0.1 s2))

  (define ss (+~ s1* s2*))

  (define-values (ss* measure-ss-rms) (rms-amplitude 0.1 ss))

  (play! (*~ ss* silence))
  (h!)

  (measure-s1-rms) ;; => #(2.9999999999627187 2.9999999999627187)
  (measure-s2-rms) ;; => #(3.998132153590563 3.998896233813645)
  (measure-ss-rms) ;; => #(5.0258347452181065 5.0260213046152185)

  ;;; 5

  (define amp-factor (/ (dB->amp 9.0) (dB->amp 0.0)))

  ;; amp-factor of n equal uncorrelated signals sum is (sqrt n)

  (* amp-factor amp-factor)

  ;;; 6

  (/ (* 2π 440.0) 44100.0)

  ;;; 7

  (- (midi-pitch->frequency 61)
     (midi-pitch->frequency 60))

  ;;; 8

  ;; wtf is cents

  ;;; 9

  ;; min (/ (sqrt N))
  ;; max 1
#+END_SRC

* Wavetables and samplers

** The Wavetable Oscillator
** Sampling
** Enveloping samplers
** Timbre stretching
** Interpolation
** Examples
** Exercises
